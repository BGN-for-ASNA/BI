---
title: "Strand"
format: html
editor: visual
filters:
  - critic-markup
---

```{r}
library(STRAND)
```
```{python}
r_sesssion = r
```


# Testing models with sr effects

```{r}
load('STRAND sim sr only.Rdata')
res = summarize_strand_results(fit)
```

```{python}
import jax.numpy as jnp
data = r_sesssion.model_dat
for k in data.keys():
  if k == "dyadic_predictors":
    for k2 in data[k].keys():
      data[k][k2] = jnp.array(data[k][k2])
  else:
    data[k] =  jnp.array(data[k])

```

```{python}
from jax import jit
from main import *


m = bi(platform='cpu')
ids = jnp.arange(0,data['N_id'])
idx = bi.net.vec_node_to_edgle(jnp.stack([ids, ids], axis = -1))
@jit
def logit(x):
    return jnp.log(x / (1 - x))

def model(idx, result_outcomes,focal_individual_predictors, target_individual_predictors):
    N_id = ids.shape[0]

    ## Block ---------------------------------------
    B = bi.dist.normal(logit(0.1/jnp.sqrt(N_id)), 2.5, shape=(1,), name = 'block')

    #SR ---------------------------------------
    sr_terms, focal_effects, target_effects = bi.net.nodes_terms(focal_individual_predictors, target_individual_predictors)# shape = N_id
    sr_rf, sr_raw, sr_sigma, sr_L = bi.net.nodes_random_effects(N_id, cholesky_density = 2) # shape = N_id
    sender_receiver = sr_terms + sr_rf
    
    ### Dyadic--------------------------------------  
    dr, dr_raw, dr_sigma, dr_L = bi.net.dyadic_random_effects(idx.shape[0], cholesky_density = 2)# shape = n dyads

    ## SR ---------------------------------------                                                      
    lk('Y', Poisson(jnp.exp(B[0] + sender_receiver + dr)), obs=result_outcomes)  

    ## NBDA -----------------------------     

m.data_on_model = dict(
    idx = idx,
    result_outcomes = bi.net.mat_to_edgl(data['outcomes'][:,:,0]), 
    focal_individual_predictors = data['individual_predictors'].reshape(1,50),
    target_individual_predictors = data['individual_predictors'].reshape(1,50),
)

m.run(model) 
summary = m.summary()
summary.loc[['focal_effects[0]', 'target_effects[0]', 'block[0]',]]
# focal_effects = -1.9,
# target_effects =  1.3
# block =  -4
```

# Testing models with sr and dyadic effects

```{r}
load('STRAND sim sr dyad.Rdata')
res = summarize_strand_results(fit)
```

```{python}
data = r_sesssion.model_dat
for k in data.keys():
  if k == "dyadic_predictors":
    for k2 in data[k].keys():
      data[k][k2] = jnp.array(data[k][k2])
  else:
    data[k] =  jnp.array(data[k])
    
data['outcomes'] = data['outcomes'].reshape(data['N_id'], data['N_id']).T.astype(int)
kinship = data['dyadic_predictors']["Kinship"].reshape(data['N_id'],data['N_id']).T
exposure = data['exposure'].reshape(data['N_id'],data['N_id']).T
```

```{python}
m = bi(platform='cpu')
# Building model and sampling it ------------------
ids = jnp.arange(0,data['N_id'])
idx = bi.net.vec_node_to_edgle(jnp.stack([ids, ids], axis = -1))

@jit
def logit(x):
    return jnp.log(x / (1 - x))

def model2(idx, result_outcomes, dyad_effects, focal_individual_predictors, target_individual_predictors):
    N_id = ids.shape[0]

    # Block ---------------------------------------
    B = bi.dist.normal(logit(0.1/jnp.sqrt(N_id)), 2.5, shape=(1,), name = 'block')

    ## SR ---------------------------------------
    sr_terms, focal_effects, target_effects = bi.net.nodes_terms(focal_individual_predictors, target_individual_predictors)# shape = N_id
    sr_rf, sr_raw, sr_sigma, sr_L = bi.net.nodes_random_effects(N_id, cholesky_density = 2) # shape = N_id
    sender_receiver = sr_terms + sr_rf

    # Dyadic--------------------------------------  
    dr_terms, dyad_effects = bi.net.dyadic_terms(dyad_effects)
    rf, dr_raw, dr_sigma, dr_L = bi.net.dyadic_random_effects(sender_receiver.shape[0], cholesky_density = 2)
    dr = dr_terms + rf

    lk('Y', Poisson(jnp.exp(B[0] + sender_receiver + dr )), obs=result_outcomes)

m.data_on_model = dict(
    idx = idx,
    result_outcomes = bi.net.mat_to_edgl(data['outcomes']), 
    dyad_effects = bi.net.prepare_dyadic_effect(kinship), # Can be a jax array of multiple dimensions
    focal_individual_predictors = data['individual_predictors'].reshape(1,50),
    target_individual_predictors = data['individual_predictors'].reshape(1,50)
)

m.run(model2) 
summary = m.summary()
summary.loc[['focal_effects[0]', 'target_effects[0]', 'dyad_effects[0]', 'block[0]']]
# focal_effects = 1.9,
# target_effects =  1.3
# dr_effects = 1.2, 1.7, -2.2
# block =  -4
```

# Testing model with SR, dyadic effect and blcok model

## On block example

```{r}

# Make data
set.seed(1)
N_id = 10
V = 3
groups_1 = rep("Any",N_id)                                                                                  # Block Variable 1, Intercept
groups_2 = sample( c("Red","White","Blue") , size=N_id , replace=TRUE , prob=c(0.5, 0.25, 0.25) )           # Block Variable 2, Color
groups_3 = sample( c("Strangeness", "Charm") , size=N_id , replace=TRUE , prob=c(0.5,0.5) )                 # Block Variable 3, Flavor 

groups = data.frame(Intercept=as.numeric(factor(groups_1)), Color=as.numeric(factor(groups_2)), Flavor=as.numeric(factor(groups_3)))

# Block parameter structure
B_1 = matrix(-10,nrow=1,ncol=1)
B_2 = matrix(rnorm(9,0,3),nrow=3,ncol=3)
B_3 = matrix(rnorm(4,0,3),nrow=2,ncol=2)

diag(B_2) = diag(B_2) + 2
diag(B_3) = diag(B_3) + 3.5

B = list(B_1, B_2, B_3)

# Build offset matrix
block_offsets = matrix(NA, N_id, N_id)

# Loop over upper triangle and create ties from i to j, and j to i
for ( i in 1:(N_id-1) ){
    for ( j in (i+1):N_id){

 # Loop over block variables
   B_i_j = B_j_i = c()
  for(v in 1:V){
    B_i_j[v] =  B[[v]][groups[i,v] , groups[j,v] ]
    B_j_i[v] =  B[[v]][groups[j,v] , groups[i,v] ]
  }

 block_offsets[i,j] =  sum(B_i_j)
 block_offsets[j,i] =  sum(B_j_i)

 }}

# Now reshape into N_dydads X 2 matrix
melted = cbind(block_offsets[lower.tri(block_offsets,diag=FALSE)],
               block_offsets[upper.tri(block_offsets,diag=FALSE)])

block_offsets
melted

# quick check is the same both column 1 and column 2 becuase ind_1 and ind_2 are in the same block for both color and flavor
melted[1,]
groups[1:2,]

```

```{python}
grp = r_sesssion.groups
grp_1 = jnp.array(grp['Intercept'].values) - 1
grp_2 = jnp.array(grp['Color'].values) - 1
grp_3 = jnp.array(grp['Flavor'].values) - 1

B = r_sesssion.B
B1 = B[0]
B2 = B[1]
B3 = B[2]


#b, b_ij, b_ii = bi.net.block_model_prior(len(groups_2), sample = True)
#print(b)
B1_edgl = Net.block_prior_to_edglelist(grp_1, B1)
B2_edgl = Net.block_prior_to_edglelist(grp_2, B2)
B3_edgl = Net.block_prior_to_edglelist(grp_3, B3)
res = B1_edgl + B2_edgl + B3_edgl
res
```

## On simulated data

```{r}
library(STRAND)
load('STRAND sim sr dr block.Rdata')
res = summarize_strand_results(fit)
```

```{python}
data = r_sesssion.model_dat
for k in data.keys():
  if k == "dyadic_predictors":
    for k2 in data[k].keys():
      data[k][k2] = jnp.array(data[k][k2])
  else:
    data[k] =  jnp.array(data[k])
    
data['outcomes'] = data['outcomes'].reshape(data['N_id'], data['N_id']).T.astype(int)
kinship = data['dyadic_predictors']["Kinship"].reshape(data['N_id'],data['N_id']).T
exposure = data['exposure'].reshape(data['N_id'],data['N_id']).T
Any = data['block_predictors'][:,0]-1 # Blocks are vectors of group belonging, index start at 1 so we substract 1
Merica  = data['block_predictors'][:,1]-1 # Blocks are vectors of group belonging, index start at 1 so we substract 1
Quantum  = data['block_predictors'][:, 2]-1 # Blocks are vectors of group belonging, index start at 1 so we substract 1
```

```{python}
B_Merica, b_Merica, b_ij_Merica, b_ii_Merica = bi.net.block_model(Merica, 3, sample = True)
B_Merica.shape

B_Merica, b_Merica, b_ij_Merica, b_ii_Merica = bi.net.block_model(Any,1, name_b_ij = 'b_ij_Any', name_b_ii = 'b_ii_Any', sample = True)
B_Merica.shape

B_Quantum, b_Quantum, b_ij_Quantum, b_ii_Quantum = bi.net.block_model(Quantum, 2, name_b_ij = 'b_ij_Quantum', name_b_ii = 'b_ii_Quantum', sample = True)

b, b_ij, b_ii = Net.block_model_prior(2, sample = True)



N_grp = 2
b_ij_mean = 0.01
b_ij_sd = 2.5
b_ii_mean = 0.1
b_ii_sd = 2.5
name_b_ij = 'b_ij'
name_b_ii = 'b_ii'
sample = True
N_dyads = int(((N_grp*(N_grp-1))/2))
b_ij = dist.normal(Net.logit(b_ij_mean/jnp.sqrt(N_grp*0.5 + N_grp*0.5)), b_ij_sd, shape=(N_dyads, 2), name = name_b_ij, sample = True) # transfers more likely within groups
b_ii = dist.normal(Net.logit(b_ii_mean/jnp.sqrt(N_grp)), b_ii_sd, shape=(N_grp, ), name = name_b_ii, sample = sample) # transfers less likely between groups
b = Net.edgl_to_mat(b_ij, N_grp)
b = b.at[jnp.diag_indices_from(b)].set(b_ii)
        
```

```{python}
# Building model and sampling it ------------------
m = bi(platform='cpu')
ids = jnp.arange(0,data['N_id'])
idx = bi.net.vec_node_to_edgle(jnp.stack([ids, ids], axis = -1))

@jit
def logit(x):
    return jnp.log(x / (1 - x))

def model3(idx, result_outcomes, dyad_effects, focal_individual_predictors, target_individual_predictors, Any, Merica, Quantum):
    N_id = ids.shape[0]

    # Block ---------------------------------------
    B_any, b_any, b_ij_any, b_ii_any = bi.net.block_model(Any,1, name_b_ij = 'b_ij_Any', name_b_ii = 'b_ii_Any' )
    B_Merica, b_Merica, b_ij_Merica, b_ii_Merica = bi.net.block_model(Merica,  3, name_b_ij = 'b_ij_Merica', name_b_ii = 'b_ii_Merica' )
    B_Quantum, b_Quantum, b_ij_Quantum, b_ii_Quantum = bi.net.block_model(Quantum, 2, name_b_ij = 'b_ij_Quantum', name_b_ii = 'b_ii_Quantum' )

    ## SR ---------------------------------------
    sr_terms, focal_effects, target_effects = bi.net.nodes_terms(focal_individual_predictors, target_individual_predictors)# shape = N_id
    sr_rf, sr_raw, sr_sigma, sr_L = bi.net.nodes_random_effects(N_id, cholesky_density = 2) # shape = N_id
    sender_receiver = sr_terms + sr_rf

    # Dyadic--------------------------------------  
    dr_terms, dyad_effects = bi.net.dyadic_terms(dyad_effects)
    rf, dr_raw, dr_sigma, dr_L = bi.net.dyadic_random_effects(sender_receiver.shape[0], cholesky_density = 2)
    dr = dr_terms + rf

    lk('Y', Poisson(jnp.exp(B_any + B_Merica + B_Quantum + sender_receiver + dr )), obs=result_outcomes)

m.data_on_model = dict(
    idx = idx,
    Any = Any, 
    Merica = Merica, 
    Quantum = Quantum,
    result_outcomes = bi.net.mat_to_edgl(data['outcomes']), 
    dyad_effects = bi.net.mat_to_edgl(kinship),
    focal_individual_predictors = data['individual_predictors'].reshape(1,50),
    target_individual_predictors = data['individual_predictors'].reshape(1,50)
)

m.run(model3) 
summary = m.summary()
summary.loc[['focal_effects[0]', 'target_effects[0]', 'dyad_effects[0]',
'b_ii_Any[0]',
'b_ii_Merica[0]',
'b_ii_Merica[1]',
'b_ii_Merica[2]',
'b_ii_Quantum[0]',
'b_ii_Quantum[1]',
'b_ij_Merica[0, 0]',
'b_ij_Merica[0, 1]',
'b_ij_Merica[1, 0]',
'b_ij_Merica[1, 1]',
'b_ij_Merica[2, 0]',
'b_ij_Merica[2, 1]',
'b_ij_Quantum[0, 0]',
'b_ij_Quantum[0, 1]']]

# focal_effects = 1.9,
# target_effects =  1.3
# dr_effects = 1.2, 1.7, -2.2
```
