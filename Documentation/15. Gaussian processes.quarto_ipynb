{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Gaussian Processes\"\n",
        "description: \"A Bayesian approach to regression and classification that defines a distribution over functions.\"\n",
        "categories: [Regression, Non-parametric]\n",
        "image: \"Figures/15.png\"\n",
        "order: 18\n",
        "---\n",
        "\n",
        "## General Principles\n",
        "Through varying intercepts and slopes, we have seen how to quantify some of the unique features that generate variation across clusters and covariance among the observations within each cluster. But through the covariance matrix that is used to account for correlation between clusters, we are inherently assuming linear relationships between clusters. What if we want to model the relationship between two variables that are not linearly related? In this case, we can use a Gaussian Process (GP) to model the relationship between two variables. \n",
        "<!---\n",
        "Basically, a GP is a varying-slope model with a covariance matrix where each element of the matrix is a [<span style=\"color:#0D6EFD\">kernel function ðŸ›ˆ</span>]{#kernel}.\n",
        "-->\n",
        "\n",
        "## Considerations\n",
        "::: callout-caution\n",
        "- To capture complex, non-linear relationships in data where the underlying function is smooth but has an unknown functional form, GPs use a [<span style=\"color:#0D6EFD\">kernel ðŸ›ˆ</span>]{#kernel}.\n",
        "- The choice of kernel hyperparameters can significantly impact results; thus, GPs require choosing an appropriate kernel function that captures the expected behavior of your data.\n",
        "- Through kernel definition, we can incorporate domain knowledge.\n",
        "- They scale poorly with dataset size (O(nÂ³) complexity) due to matrix operations; thus, memory requirements can be substantial for large datasets, which has led to neural networks being used instead to resolve large non-linear problems.\n",
        "<!--- Check scale of the GP -->\n",
        ":::\n",
        "\n",
        "## Example\n",
        "Below is an example code snippet demonstrating Gaussian Process regression using the Bayesian Inference (BI) package. Data consist of a continuous dependent variable (*total_tools*), representing the number of tools invented in the islands, and a continuous independent variable (*population*), representing the population of the islands. The goal is to estimate the effect of population on the total tools. We use the distance matrix of the islands for the kernel function in order to capture the spatial dependence of the relationship. This example is based on @mcelreath2018statistical.\n",
        "\n",
        "::: {.panel-tabset group=\"language\"}\n",
        "## Python"
      ],
      "id": "600d2d00"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from BI import bi, jnp\n",
        "import pandas as pd\n",
        "# Setup device------------------------------------------------\n",
        "m = bi(platform='cpu')\n",
        "\n",
        "# Import Data & Data Manipulation ------------------------------------------------\n",
        "# Import\n",
        "from importlib.resources import files\n",
        "data_path = m.load.kline2(only_path=True)\n",
        "m.data(data_path, sep=';') \n",
        "\n",
        "\n",
        "data_path2 = files('BI.Resources') / 'islandsDistMatrix.csv'\n",
        "islandsDistMatrix = pd.read_csv(data_path2, index_col=0)\n",
        "\n",
        "m.data_to_model(['total_tools', 'population'])\n",
        "m.data_on_model[\"society\"] = jnp.arange(0,10)# index observations\n",
        "m.data_on_model[\"Dmat\"] = islandsDistMatrix.values # Distance matrix\n",
        "\n",
        "def model(Dmat, population, society, total_tools):\n",
        "    a = m.dist.exponential(1, name = 'a')\n",
        "    b = m.dist.exponential(1, name = 'b')\n",
        "    g = m.dist.exponential(1, name = 'g')\n",
        "\n",
        "    # non-centered Gaussian Process prior\n",
        "    etasq = m.dist.exponential(2, name = 'etasq')\n",
        "    rhosq = m.dist.exponential(0.5, name = 'rhosq')\n",
        "    SIGMA = etasq * jnp.exp(-rhosq * jnp.square(Dmat))\n",
        "    SIGMA = SIGMA.at[jnp.diag_indices(Dmat.shape[0])].add(etasq)\n",
        "    k = m.dist.multivariate_normal(0, SIGMA, name = 'k')\n",
        "\n",
        "    lambda_ = a * population**b / g * jnp.exp(k[society])\n",
        "\n",
        "    m.dist.poisson(lambda_, obs=total_tools)\n",
        "\n",
        "# Run sampler ------------------------------------------------\n",
        "m.fit(model) \n",
        "m.summary()"
      ],
      "id": "4a4f1fbe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Python (Build in function)"
      ],
      "id": "b1da9d30"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from BI import bi, jnp\n",
        "import pandas as pd\n",
        "# Setup device------------------------------------------------\n",
        "m = bi(platform='cpu')\n",
        "\n",
        "# Import Data & Data Manipulation ------------------------------------------------\n",
        "# Import\n",
        "from importlib.resources import files\n",
        "data_path = m.load.kline2(only_path=True)\n",
        "m.data(data_path, sep=';') \n",
        "\n",
        "islandsDistMatrix = m.load.islands_dist_matrix(frame = False)['data']\n",
        "\n",
        "m.data_to_model(['total_tools', 'population'])\n",
        "m.data_on_model[\"society\"] = jnp.arange(0,10)# index observations\n",
        "m.data_on_model[\"Dmat\"] = islandsDistMatrix # Distance matrix\n",
        "\n",
        "\n",
        "def model(Dmat, population, society, total_tools):\n",
        "    a = m.dist.exponential(1, name = 'a')\n",
        "    b = m.dist.exponential(1, name = 'b')\n",
        "    g = m.dist.exponential(1, name = 'g')\n",
        "\n",
        "    k = m.gaussian.gaussian_process(Dmat)\n",
        "\n",
        "    lambda_ = a * population**b / g * jnp.exp(k[society])\n",
        "\n",
        "    m.dist.poisson(lambda_, obs=total_tools)\n",
        "\n",
        "# Run sampler ------------------------------------------------\n",
        "m.fit(model) \n",
        "m.summary()"
      ],
      "id": "d2b3188e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## R\n",
        "```r\n",
        "library(BayesianInference)\n",
        "jnp = reticulate::import('jax.numpy')\n",
        "pd = reticulate::import('pandas')\n",
        "# setup platform------------------------------------------------\n",
        "m=importBI(platform='cpu')\n",
        "\n",
        "# Import data ------------------------------------------------\n",
        "m$data(m$load$kline2(only_path=T), sep=';')\n",
        "islandsDistMatrix = m$load$islands_dist_matrix(frame = FALSE)$data\n",
        "m$data_to_model(list('total_tools', 'population'))\n",
        "m$data_on_model$society = jnp$arange(0,10, dtype='int64')\n",
        "m$data_on_model$Dmat = jnp$array(islandsDistMatrix)\n",
        "\n",
        "\n",
        "# Define model ------------------------------------------------\n",
        "model <- function(Dmat, population, society, total_tools){\n",
        "  a = bi.dist.exponential(1, name = 'a')\n",
        "  b = bi.dist.exponential(1, name = 'b')\n",
        "  g = bi.dist.exponential(1, name = 'g')\n",
        "  \n",
        "  # non-centered Gaussian Process prior\n",
        "  etasq = bi.dist.exponential(2, name = 'etasq')\n",
        "  rhosq = bi.dist.exponential(0.5, name = 'rhosq')\n",
        "  k = m$gaussian$gaussian_process(Dmat, etasq, rhosq, 0.01)\n",
        "  \n",
        "  lambda_ = a * population**b / g * jnp$exp(k[society])\n",
        "  m$dist$poisson(lambda_, obs=total_tools)\n",
        "}\n",
        "\n",
        "# Run MCMC ------------------------------------------------\n",
        "m$fit(model) # Optimize model parameters through MCMC sampling\n",
        "\n",
        "# Summary ------------------------------------------------\n",
        "m$summary() # Get posterior distribution\n",
        "\n",
        "```\n",
        "\n",
        "## Julia\n",
        "```julia\n",
        "using BayesianInference\n",
        "\n",
        "# Setup device------------------------------------------------\n",
        "m = importBI(platform=\"cpu\")\n",
        "\n",
        "# Import Data & Data Manipulation ------------------------------------------------\n",
        "# Import\n",
        "data_path = m.load.kline2(only_path = true)\n",
        "m.data(data_path, sep=\";\") \n",
        "\n",
        "islandsDistMatrix = m.load.islands_dist_matrix(frame = false)[\"data\"]\n",
        "m.data_to_model([\"total_tools\", \"population\"])\n",
        "m.data_on_model[\"society\"] = jnp.arange(0,10)# index observations\n",
        "m.data_on_model[\"Dmat\"] = jnp.array(islandsDistMatrix) # Distance matrix\n",
        "\n",
        "\n",
        "\n",
        "# Define model ------------------------------------------------\n",
        "@BI function model(Dmat, population, society, total_tools)\n",
        "    a = m.dist.exponential(1, name = \"a\")\n",
        "    b = m.dist.exponential(1, name = \"b\")\n",
        "    g = m.dist.exponential(1, name = \"g\")\n",
        "\n",
        "    # non-centered Gaussian Process prior\n",
        "    etasq = m.dist.exponential(2, name = \"etasq\")\n",
        "    rhosq = m.dist.exponential(0.5, name = \"rhosq\")\n",
        "    SIGMA = etasq * jnp.exp(-rhosq * jnp.square(Dmat))\n",
        "    SIGMA = SIGMA.at[jnp.diag_indices(Dmat.shape[0])].add(etasq)\n",
        "    k = m.dist.multivariate_normal(0, SIGMA, name = \"k\")\n",
        "\n",
        "    lambda_ = a * population^b / g * jnp.exp(k[society])\n",
        "\n",
        "    m.dist.poisson(lambda_, obs=total_tools)\n",
        "\n",
        "end\n",
        "\n",
        "# Run mcmc ------------------------------------------------\n",
        "m.fit(model)  # Optimize model parameters through MCMC sampling\n",
        "\n",
        "# Summary ------------------------------------------------\n",
        "m.summary() # Get posterior distributions\n",
        "```\n",
        ":::\n",
        "\n",
        "## Mathematical Details\n",
        "### *Formula*\n",
        "\n",
        "\n",
        "The following equation allows us to evaluate the relationship between the dependent variable $Y$ distributed normal, and the independent variable $X$ while incorporating a GP for the effect of variable $Q$:\n",
        "\n",
        "$$\n",
        "Y_{[i]} \\sim \\text{Normal}( \\alpha + \\beta  X_{[i]} + \\gamma_{[Q_{[i]}]}, \\sigma)\n",
        "$$\n",
        "\n",
        "where:\n",
        "\n",
        "- $Y_{[i]}$ is the i-th value for the dependent variable $Y$.\n",
        "\n",
        "- $\\alpha$ is the intercept term.\n",
        "\n",
        "- $\\beta$ is the regression coefficient term.\n",
        "\n",
        "- $X_{[i]}$ is the i-th value for the independent variable $X$.\n",
        "\n",
        "- $Q_{[i]}$ is an integer-valued independent variable (e.g., year-of-birth, age, year) for observation $i$.\n",
        "\n",
        "- $\\gamma$ is a vector output from a Gaussian process:\n",
        "\n",
        "$$\n",
        "\\gamma\n",
        "\\sim \\text{MVNormal} \\left(\n",
        "Z,\n",
        "\\varsigma\\Omega\\varsigma\n",
        "\\right)\n",
        "$$\n",
        "\n",
        "where:\n",
        "\n",
        "- $Z$ represents the mean vector of the multivariate normal distribution and set to [<span style=\"color:#0D6EFD\">zero ðŸ›ˆ</span>]{#kernelMean0}.\n",
        "\n",
        "- $\\varsigma$ is a diagonal matrix of standard deviations. \n",
        "\n",
        "- $\\Omega$ is a correlation matrix. \n",
        "\n",
        "\n",
        "- Multiple kernel functions for $\\Omega$ exist and will be discussed in the [Note(s)](#notes) section. But the most common one is the quadratic kernel:\n",
        "\n",
        "$$\n",
        "\\Omega_{[i,j]} = \\eta \\exp(-\\phi^2 D_{[i,j]}^2) \n",
        "$$\n",
        "\n",
        "Where:\n",
        "\n",
        "- $\\eta$ is the maximal correlation.\n",
        "  \n",
        "- $\\phi$ determines the rate of decline.\n",
        "  \n",
        "- $D_{[i,j]}$ is the distance between the $i$-th and $j$-th categories.\n",
        "  \n",
        "\n",
        "\n",
        "### *Bayesian model*\n",
        "In the Bayesian formulation, we define each parameter with [<span style=\"color:#0D6EFD\">priors ðŸ›ˆ</span>]{#prior}. We can express a Bayesian version of this GP using the following model:\n",
        "\n",
        "$$\n",
        "Y_i = \\alpha + \\beta  X_i + \\gamma_{Z_i}\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\gamma \\sim \\text{MVNormal} \\left(\n",
        "\\begin{pmatrix}\n",
        "    0 \\\\\n",
        "    \\vdots \\\\\n",
        "    0\n",
        "\\end{pmatrix},\n",
        "K\n",
        "\\right)\n",
        "$$\n",
        "\n",
        "$$\n",
        "K_{ij} = \\eta^2 \\exp(-p^2D_{ij}^2) + \\delta_{ij} \\sigma^2 \n",
        "$$\n",
        "\n",
        "$$\n",
        "\\alpha \\sim \\text{Normal}(0,1)\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\eta^2 \\sim \\text{HalfCauchy}(0,1)\n",
        "$$\n",
        "\n",
        "$$\n",
        "p^2 \\sim \\text{HalfCauchy}(0,1)\n",
        "$$\n",
        "\n",
        "where:\n",
        "\n",
        "- $Y_i$ is the i-th value for the dependent variable $Y$.\n",
        "\n",
        "- $\\alpha$ is the intercept term with a prior of $\\text{Normal}(0,1)$.\n",
        "\n",
        "- $\\beta$ is the regression coefficient term with a prior of $\\text{Normal}(0,1)$.\n",
        "\n",
        "- $X_i$ is the i-th value for the independent variable $X$.\n",
        "\n",
        "- $\\gamma_{Z_i}$ is the Gaussian process i-th value for the independent variable $Z$.\n",
        "\n",
        "- $\\gamma$ is the latent function modeled by the GP.\n",
        "\n",
        "- $K_{ij}$ is the kernel function evaluated at the corresponding points, $K_{ij} = k(Z_i, Z_j)$, with priors of HalfCauchy(0,1) for $\\eta^2$ and $p^2$ to ensure positive values.\n",
        "\n",
        "\n",
        "## Notes{#notes}\n",
        "::: callout-note\n",
        "\n",
        "Common kernel functions include:\n",
        "\n",
        "- *Radial Basis Function* (RBF) or Squared Exponential Kernel:\n",
        "$$k(x,x') = \\sigma^2 \\exp\\left(-\\frac{||x-x'||^2}{2l^2}\\right)$$\n",
        "\n",
        "\n",
        "- *Rational Quadratic Kernel*, this kernel is equivalent to adding together many RBF kernels with different length scales:\n",
        "$$k(x,x') = \\sigma^2 \\left(1 + \\frac{||x-x'||^2}{2l^2}\\right)^{-\\alpha}$$\n",
        "\n",
        "- *Periodic kernel* allows for modeling functions that repeat themselves exactly:\n",
        "$$k(x,x') = \\sigma^2 \\exp\\left(-\\frac{2\\sin^2(\\pi||x-x'||/p)}{l^2}\\right)$$\n",
        "\n",
        "- *Locally Periodic Kernel*:\n",
        "\n",
        "$$k(x,x') = \\sigma^2 \\exp\\left(-\\frac{2\\sin^2(\\pi||x-x'||/p)}{l^2}\\right) \\exp\\left(-\\frac{||x-x'||^2}{2l^2}\\right)$$ \n",
        "\n",
        "- Any slope or intercept in your model can be defined using a Gaussian Process.\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "## Reference(s)\n",
        "::: {#refs}\n",
        ":::\n",
        "\n",
        "https://www.cs.toronto.edu/~duvenaud/cookbook/"
      ],
      "id": "91e1270a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/sosa/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}