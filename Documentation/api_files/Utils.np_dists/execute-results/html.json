{
  "hash": "e6989b6a010510d09b039a52411df0cc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Sampled from distributions\n---\n\n\n`Utils.np_dists.UnifiedDist` is a class to unify various distribution methods and provide a consistent interface for sampling and inference.\n\n## Methods\n\n| Name | Description |\n| --- | --- |\n| [asymmetric_laplace](#BI.Utils.np_dists.UnifiedDist.asymmetric_laplace) | ### AsymmetricLaplace |\n| [asymmetric_laplace_quantile](#BI.Utils.np_dists.UnifiedDist.asymmetric_laplace_quantile) | ### AsymmetricLaplaceQuantile |\n| [bernoulli](#BI.Utils.np_dists.UnifiedDist.bernoulli) | ### Bernoulli distribution. |\n| [bernoulli_logits](#BI.Utils.np_dists.UnifiedDist.bernoulli_logits) | ### BernoulliLogits |\n| [bernoulli_probs](#BI.Utils.np_dists.UnifiedDist.bernoulli_probs) | ### BernoulliProbs |\n| [beta](#BI.Utils.np_dists.UnifiedDist.beta) | ### Beta Distribution |\n| [beta_binomial](#BI.Utils.np_dists.UnifiedDist.beta_binomial) | ### BetaBinomial Distribution |\n| [beta_proportion](#BI.Utils.np_dists.UnifiedDist.beta_proportion) | ### BetaProportion distribution. |\n| [binomial](#BI.Utils.np_dists.UnifiedDist.binomial) | ### Binomial distribution. |\n| [binomial_logits](#BI.Utils.np_dists.UnifiedDist.binomial_logits) | ### BinomialLogits Distribution |\n| [binomial_probs](#BI.Utils.np_dists.UnifiedDist.binomial_probs) | ### BinomialProbs |\n| [car](#BI.Utils.np_dists.UnifiedDist.car) | ### Conditional Autoregressive (CAR) Distribution |\n| [categorical](#BI.Utils.np_dists.UnifiedDist.categorical) | ### Categorical distribution. |\n| [categorical_logits](#BI.Utils.np_dists.UnifiedDist.categorical_logits) | ### Categorical Logits Distribution |\n| [categorical_probs](#BI.Utils.np_dists.UnifiedDist.categorical_probs) | ### Categorical Probs distribution. |\n| [cauchy](#BI.Utils.np_dists.UnifiedDist.cauchy) | ### Cauchy Distribution |\n| [chi2](#BI.Utils.np_dists.UnifiedDist.chi2) | ### Chi-squared distribution. |\n| [circulant_normal](#BI.Utils.np_dists.UnifiedDist.circulant_normal) | ### Circulant Normal Distribution |\n| [delta](#BI.Utils.np_dists.UnifiedDist.delta) | ### Delta distribution. |\n| [dirichlet](#BI.Utils.np_dists.UnifiedDist.dirichlet) | ### Dirichlet |\n| [dirichlet_multinomial](#BI.Utils.np_dists.UnifiedDist.dirichlet_multinomial) | ### Dirichlet-Multinomial Distribution. |\n| [discrete_uniform](#BI.Utils.np_dists.UnifiedDist.discrete_uniform) | ### Discrete Uniform Distribution |\n| [doubly_truncated_power_law](#BI.Utils.np_dists.UnifiedDist.doubly_truncated_power_law) | ### Doubly Truncated Power Law distribution. |\n| [euler_maruyama](#BI.Utils.np_dists.UnifiedDist.euler_maruyama) | ###  Eulerâ€“Maruyama Distribution |\n| [exponential](#BI.Utils.np_dists.UnifiedDist.exponential) | ### Exponential distribution. |\n| [folded_distribution](#BI.Utils.np_dists.UnifiedDist.folded_distribution) | ### Folded distribution |\n| [gamma](#BI.Utils.np_dists.UnifiedDist.gamma) | ### Gamma Distribution |\n| [gamma_poisson](#BI.Utils.np_dists.UnifiedDist.gamma_poisson) | ### GammaPoisson Distribution |\n| [gaussian_copula](#BI.Utils.np_dists.UnifiedDist.gaussian_copula) | ###  Gaussian Copula Distribution |\n| [gaussian_copula_beta](#BI.Utils.np_dists.UnifiedDist.gaussian_copula_beta) | ### Gaussian Copula Beta distribution. |\n| [gaussian_random_walk](#BI.Utils.np_dists.UnifiedDist.gaussian_random_walk) | ### Gaussian Random Walk Distribution. |\n| [gaussian_state_space](#BI.Utils.np_dists.UnifiedDist.gaussian_state_space) | ### Gaussian State Space Distribution |\n| [geometric](#BI.Utils.np_dists.UnifiedDist.geometric) | ### Geometric distribution. |\n| [geometric_logits](#BI.Utils.np_dists.UnifiedDist.geometric_logits) | ### GeometricLogits Distribution |\n| [geometric_probs](#BI.Utils.np_dists.UnifiedDist.geometric_probs) | ### GeometricProbs |\n| [gompertz](#BI.Utils.np_dists.UnifiedDist.gompertz) | ### Gompertz Distribution. |\n| [gumbel](#BI.Utils.np_dists.UnifiedDist.gumbel) | ### Gumbel |\n| [half_cauchy](#BI.Utils.np_dists.UnifiedDist.half_cauchy) | ### HalfCauchy Distribution |\n| [half_normal](#BI.Utils.np_dists.UnifiedDist.half_normal) | ### HalfNormal |\n| [improper_uniform](#BI.Utils.np_dists.UnifiedDist.improper_uniform) | ### Improper Uniform Distribution |\n| [inverse_gamma](#BI.Utils.np_dists.UnifiedDist.inverse_gamma) | ### Inverse Gamma Distribution |\n| [kumaraswamy](#BI.Utils.np_dists.UnifiedDist.kumaraswamy) | ### Kumaraswamy Distribution. |\n| [laplace](#BI.Utils.np_dists.UnifiedDist.laplace) | ### Laplace Distribution |\n| [left_truncated_distribution](#BI.Utils.np_dists.UnifiedDist.left_truncated_distribution) | ### Left Truncated Distribution |\n| [levy](#BI.Utils.np_dists.UnifiedDist.levy) | ### Levy distribution. |\n| [lkj](#BI.Utils.np_dists.UnifiedDist.lkj) | ### Lewandowski Kurowicka Joe distribution  |\n| [lkj_cholesky](#BI.Utils.np_dists.UnifiedDist.lkj_cholesky) | ### LKJ Cholesky Distribution |\n| [log_normal](#BI.Utils.np_dists.UnifiedDist.log_normal) | ### LogNormal distribution. |\n| [log_uniform](#BI.Utils.np_dists.UnifiedDist.log_uniform) | ### LogUniform |\n| [logistic](#BI.Utils.np_dists.UnifiedDist.logistic) | ### Logistic Distribution |\n| [low_rank_multivariate_normal](#BI.Utils.np_dists.UnifiedDist.low_rank_multivariate_normal) | ### Low Rank Multivariate Normal Distribution |\n| [lower_truncated_power_law](#BI.Utils.np_dists.UnifiedDist.lower_truncated_power_law) | ### LowerTruncatedPowerLaw |\n| [matrix_normal](#BI.Utils.np_dists.UnifiedDist.matrix_normal) | ### Matrix Normal Distribution |\n| [mixture](#BI.Utils.np_dists.UnifiedDist.mixture) | ### A marginalized finite mixture of component distributions. |\n| [mixture_general](#BI.Utils.np_dists.UnifiedDist.mixture_general) | ### Mixture General Distribution |\n| [mixture_same_family](#BI.Utils.np_dists.UnifiedDist.mixture_same_family) | ###  Finite mixture of component distributions from the same family. |\n| [multinomial](#BI.Utils.np_dists.UnifiedDist.multinomial) | ### Multinomial distribution. |\n| [multinomial_logits](#BI.Utils.np_dists.UnifiedDist.multinomial_logits) | ### Multinomial Logits Distribution |\n| [multinomial_probs](#BI.Utils.np_dists.UnifiedDist.multinomial_probs) | ### Multinomial Probs Distribution |\n| [multivariate_normal](#BI.Utils.np_dists.UnifiedDist.multivariate_normal) | ### Multivariate Normal distribution. |\n| [multivariate_student_t](#BI.Utils.np_dists.UnifiedDist.multivariate_student_t) | ### Multivariate Student's t Distribution |\n| [negative_binomial](#BI.Utils.np_dists.UnifiedDist.negative_binomial) | ### NegativeBinomial distribution. |\n| [negative_binomial_logits](#BI.Utils.np_dists.UnifiedDist.negative_binomial_logits) | ### NegativeBinomialLogits |\n| [negative_binomial_probs](#BI.Utils.np_dists.UnifiedDist.negative_binomial_probs) | ### NegativeBinomial distribution with probabilities. |\n| [normal](#BI.Utils.np_dists.UnifiedDist.normal) | ### Normal Distribution |\n| [ordered_logistic](#BI.Utils.np_dists.UnifiedDist.ordered_logistic) | ### OrderedLogistic |\n| [pareto](#BI.Utils.np_dists.UnifiedDist.pareto) | ### Pareto Distribution |\n| [poisson](#BI.Utils.np_dists.UnifiedDist.poisson) | ### Poisson Distribution |\n| [projected_normal](#BI.Utils.np_dists.UnifiedDist.projected_normal) | ### ProjectedNormal distribution. |\n| [relaxed_bernoulli](#BI.Utils.np_dists.UnifiedDist.relaxed_bernoulli) | ### Relaxed Bernoulli distribution. |\n| [relaxed_bernoulli_logits](#BI.Utils.np_dists.UnifiedDist.relaxed_bernoulli_logits) | ### Relaxed Bernoulli Logits Distribution. |\n| [right_truncated_distribution](#BI.Utils.np_dists.UnifiedDist.right_truncated_distribution) | ### RightTruncatedDistribution |\n| [sine_bivariate_vonmises](#BI.Utils.np_dists.UnifiedDist.sine_bivariate_vonmises) | ### Sine Bivariate Von Mises Distribution |\n| [sine_skewed](#BI.Utils.np_dists.UnifiedDist.sine_skewed) | ### Sine-skewing distribution |\n| [soft_laplace](#BI.Utils.np_dists.UnifiedDist.soft_laplace) | ### SoftLaplace |\n| [student_t](#BI.Utils.np_dists.UnifiedDist.student_t) | ### Student's t-distribution. |\n| [truncated_cauchy](#BI.Utils.np_dists.UnifiedDist.truncated_cauchy) | ### Truncated Cauchy distribution. |\n| [truncated_distribution](#BI.Utils.np_dists.UnifiedDist.truncated_distribution) | ### TruncatedDistribution |\n| [truncated_normal](#BI.Utils.np_dists.UnifiedDist.truncated_normal) | ### Truncated Normal distribution. |\n| [truncated_polya_gamma](#BI.Utils.np_dists.UnifiedDist.truncated_polya_gamma) | ### TruncatedPolyaGamma Distribution |\n| [two_sided_truncated_distribution](#BI.Utils.np_dists.UnifiedDist.two_sided_truncated_distribution) | ### TwoSided Truncated Distribution |\n| [uniform](#BI.Utils.np_dists.UnifiedDist.uniform) | ### Uniform Distribution |\n| [unit](#BI.Utils.np_dists.UnifiedDist.unit) | ### Unit Distribution |\n| [weibull](#BI.Utils.np_dists.UnifiedDist.weibull) | ### Weibull Distribution |\n| [wishart](#BI.Utils.np_dists.UnifiedDist.wishart) | ### Wishart Distribution |\n| [wishart_cholesky](#BI.Utils.np_dists.UnifiedDist.wishart_cholesky) | ### WishartCholesky Distribution |\n| [zero_inflated_distribution](#BI.Utils.np_dists.UnifiedDist.zero_inflated_distribution) | ### Generic Zero Inflated distribution. |\n| [zero_inflated_negative_binomial2](#BI.Utils.np_dists.UnifiedDist.zero_inflated_negative_binomial2) | ### Zero-Inflated Negative Binomial 2 distribution. |\n| [zero_inflated_poisson](#BI.Utils.np_dists.UnifiedDist.zero_inflated_poisson) | ### A Zero Inflated Poisson distribution. |\n| [zero_sum_normal](#BI.Utils.np_dists.UnifiedDist.zero_sum_normal) | ### Zero Sum Normal Distribution |\n\n### Asymmetric Laplace { #BI.Utils.np_dists.UnifiedDist.asymmetric_laplace }\n\n```python\nUtils.np_dists.UnifiedDist.asymmetric_laplace(\n    loc=0.0,\n    scale=1.0,\n    asymmetry=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n  Samples from an Asymmetric Laplace distribution.\n\n  The Asymmetric Laplace distribution is a generalization of the Laplace distribution,\n  where the two sides of the distribution are scaled differently. It is defined by\n  a location parameter (loc), a scale parameter (scale), and an asymmetry parameter (asymmetry).\n\n\n\n\n\n\n```{latex}\n  \\begin{align*}\n  f(x) = \\frac{\\text{asymmetry}}{\\text{scale}(\\text{asymmetry}^2+1)} \\exp\\left(-\\frac{\\text{asymmetry}}{\\text{scale}}( \\text{loc} - x)\\right) \\\\\n  \\text{if } x < \\text{loc} \\\\ \n  \\frac{\\text{asymmetry}}{\\text{scale}(\\text{asymmetry}^2+1)} \\exp\\left(-\\frac{1}{\\text{scale} \\cdot \\text{asymmetry}}(x - \\text{loc})\\right) \\\\             \n  \\text{if } x \\ge \\text{loc}\n  \\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n\n  - *loc* (jnp.ndarray or float): Location parameter of the distribution.\n\n  - *scale* (jnp.ndarray or float): Scale parameter of the distribution.\n\n  - *asymmetry* (jnp.ndarray or float): Asymmetry parameter of the distribution.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n          JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - **create_obj (bool): If True, returns the raw NumPyro distribution object instead of creating a\n          sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  - validate_args (bool, optional): Whether to enable validation of distribution parameters. Defaults to `None`.\n\n  #### Returns:\n\n- When `sample=False`: A NumPyro AsymmetricLaplace distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the AsymmetricLaplace distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n\n  ```python\n      from BI import bi\n      m = bi('cpu')\n      m.dist.asymmetric_laplace(loc=0.0, scale=1.0, asymmetry=1.0, sample=True)\n  ```\n\n  #### Wrapper of:\n\n      https://num.pyro.ai/en/stable/distributions.html#asymmetriclaplace\n\n\n### AsymmetricLaplaceQuantile { #BI.Utils.np_dists.UnifiedDist.asymmetric_laplace_quantile }\n\n```python\nUtils.np_dists.UnifiedDist.asymmetric_laplace_quantile(\n    loc=0.0,\n    scale=1.0,\n    quantile=0.5,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n  Samples from an AsymmetricLaplaceQuantile distribution.\n\n  This distribution is an alternative parameterization of the AsymmetricLaplace\n  distribution, commonly used in Bayesian quantile regression. It utilizes a\n  `quantile` parameter to define the balance between the left- and right-hand\n  sides of the distribution, representing the proportion of probability density\n  that falls to the left-hand side.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     f(x) = \\frac{1}{2 \\sigma} \\exp\\left(-\\frac{|x - \\mu|}{\\sigma} \\frac{1}{q-1}\\right) \\left(1 - \\frac{1}{2q}\\right)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  Args:\n  - *loc* (float): The location parameter of the distribution.\n\n  - *sample* (float): The scale parameter of the distribution.\n\n      quantile (float): The quantile parameter, representing the proportion of\n          probability density to the left of the median. Must be between 0 and 1.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the\n          distribution's batch shape. When `sample=True` (direct sampling), this\n          is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event\n          dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object\n          instead of creating a sample site. This is essential for building\n          complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro AsymmetricLaplaceQuantile distribution object\n          (for model building).\n\n- When `sample=True`: A JAX array of samples drawn from the\n          AsymmetricLaplaceQuantile distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced\n          use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.asymmetric_laplace_quantile(loc=0.0, scale=1.0, quantile=0.5, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#asymmetriclaplacequantile\n\n##### bernoulli { #BI.Utils.np_dists.UnifiedDist.bernoulli }\n\n```python\nUtils.np_dists.UnifiedDist.bernoulli(\n    probs=None,\n    logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Bernoulli distribution.\n\nThe Bernoulli distribution models a single trial with two possible outcomes: success or failure.\nIt is parameterized by the probability of success, often denoted as 'p'.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   P(X=1) = p \\\\\n   P(X=0) = 1 - p\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *probs* (jnp.ndarray, optional):  Probability of success for each Bernoulli trial. Must be between 0 and 1.\n    logits (jnp.ndarray, optional): Log-odds of success for each Bernoulli trial.  `probs = sigmoid(logits)`.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations.\n\n- *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Bernoulli distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the Bernoulli distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.bernoulli(probs=0.7, sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#bernoulli\n\n##### bernoulli_logits { #BI.Utils.np_dists.UnifiedDist.bernoulli_logits }\n\n```python\nUtils.np_dists.UnifiedDist.bernoulli_logits(\n    logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### BernoulliLogits\n\n  Samples from a Bernoulli distribution parameterized by logits.\n\n  The Bernoulli distribution models a single binary event (success or failure),\n  parameterized by the log-odds ratio of success.  The probability of success\n  is given by the sigmoid function applied to the logit.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      P(x) = \\sigma(logits)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      logits (jnp.ndarray, optional): Log-odds ratio of success.  Must be real-valued.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the\n          distribution's batch shape. When `sample=True` (direct sampling), this\n          is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int, optional): The number of batch dimensions to reinterpret as\n      - *event* dimensions (used in model building). Defaults to 0.\n\n  - *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask\n          observations. Defaults to None.\n\n  - *create_obj* (bool, optional): If True, returns the raw NumPyro\n          distribution object instead of creating a sample site. This is\n          essential for building complex distributions like `MixtureSameFamily`.\n          Defaults to False.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro BernoulliLogits distribution object (for\n          model building).\n\n- When `sample=True`: A JAX array of samples drawn from the BernoulliLogits\n          distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced\n          use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.bernoulli_logits(logits=jnp.array([0.2, 1, 2]), sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#bernoulli-logits\n\n##### bernoulli_probs { #BI.Utils.np_dists.UnifiedDist.bernoulli_probs }\n\n```python\nUtils.np_dists.UnifiedDist.bernoulli_probs(\n    probs,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### BernoulliProbs\n\nSamples from a Bernoulli distribution parameterized by probabilities.\n\nThe Bernoulli distribution models the probability of success in a single trial,\nwhere the outcome is binary (success or failure). It is characterized by a single\nparameter, `probs`, representing the probability of success.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    P(X=1) = p\n\\end{align*}\n```            \n\n\n\n\n\nwhere:\n    p is the probability of success (0 <= p <= 1)\n\n\n#### Args:\n- *probs* (jnp.ndarray): The probability of success for each Bernoulli trial.\n        Must be between 0 and 1.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n        (model building), this is used with `.expand(shape)` to set the\n        distribution's batch shape. When `sample=True` (direct sampling), this\n        is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event\n        dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object\n        instead of creating a sample site. This is essential for building\n        complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    BernoulliProbs: A NumPyro BernoulliProbs distribution object (for model\n        building).\n\n    jnp.ndarray: A JAX array of samples drawn from the BernoulliProbs\n        distribution (for direct sampling).\n\n    NumPyro distribution object: The raw NumPyro distribution object (for\n        advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.bernoulli_probs(probs=jnp.array([0.2, 0.7, 0.5]), sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#bernoulliprobs\n\n##### beta { #BI.Utils.np_dists.UnifiedDist.beta }\n\n```python\nUtils.np_dists.UnifiedDist.beta(\n    concentration1,\n    concentration0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Beta Distribution\n\nSamples from a Beta distribution, defined on the interval [0, 1].\nThe Beta distribution is a versatile distribution often used to model\nprobabilities or proportions. It is parameterized by two positive shape\nparameters, often referred to as concentration parameters in the NumPyro\ncontext.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x) = \\frac{x^{\\alpha - 1} (1 - x)^{\\beta - 1}}{B(\\alpha, \\beta)}\n\\end{align*}\n```\n\n\n\n\n\n\nwhere :num:math:`\\alpha` and :num:math:`\\beta` are the concentration parameters,\nand :num:math:`B(x, y)` is the Beta function.\n\n\n#### Args:\n    concentration1 (jnp.ndarray): The first concentration parameter (shape parameter). Must be positive.\n    concentration0 (jnp.ndarray): The second concentration parameter (shape parameter). Must be positive.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n        this is used with `.expand(shape)` to set the distribution's batch shape.\n        When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n        JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample\n        site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    Beta: A NumPyro Beta distribution object (for model building).\n    jnp.ndarray: A JAX array of samples drawn from the Beta distribution (for direct sampling).\n    Beta: The raw NumPyro distribution object (for advanced use cases).\n\n#### #### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.beta(concentration1=1.0, concentration0=1.0, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#beta\n\n##### beta_binomial { #BI.Utils.np_dists.UnifiedDist.beta_binomial }\n\n```python\nUtils.np_dists.UnifiedDist.beta_binomial(\n    concentration1,\n    concentration0,\n    total_count=1,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### BetaBinomial Distribution\n\n  Samples from a BetaBinomial distribution, a compound distribution where the probability of success in a binomial\n  experiment is drawn from a Beta distribution. This models situations where the underlying probability of success\n  is not fixed but varies according to a prior belief represented by the Beta distribution.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     P(X=k) = \\binom{n}{k} \\frac{\\Gamma(\\alpha + k)}{\\Gamma(\\alpha + \\beta + n - k)} \\frac{\\Gamma(\\beta + n - k)}{\\Gamma(\\beta)}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      concentration1 (jnp.ndarray): The first concentration parameter (alpha) of the Beta distribution.\n      concentration0 (jnp.ndarray): The second concentration parameter (beta) of the Beta distribution.\n      total_count (jnp.ndarray): The number of Bernoulli trials in the Binomial part of the distribution.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro BetaBinomial distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the BetaBinomial distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.beta_binomial(concentration1=1.0, concentration0=1.0, total_count=10, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#betabinomial\n\n##### beta_proportion { #BI.Utils.np_dists.UnifiedDist.beta_proportion }\n\n```python\nUtils.np_dists.UnifiedDist.beta_proportion(\n    mean,\n    concentration,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### BetaProportion distribution.\n\nThe BetaProportion distribution is a reparameterization of the conventional\nBeta distribution in terms of a the variate mean and a\nprecision parameter. It's useful for modeling rates and proportions.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x) = \\frac{x^{\\alpha - 1} (1 - x)^{\\beta - 1}}{B(\\alpha, \\beta)}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    mean (jnp.ndarray): The mean of the BetaProportion distribution,\n        must be between 0 and 1.\n\n    concentration (jnp.ndarray): The concentration parameter of the BetaProportion distribution.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n        (model building), this is used with `.expand(shape)` to set the\n        distribution's batch shape. When `sample=True` (direct sampling),\n        this is used as `sample_shape` to draw a raw JAX array of the\n        given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event\n        dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution\n        object instead of creating a sample site. This is essential for\n        building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    A NumPyro BetaProportion distribution object (for model building).\n    A JAX array of samples drawn from the BetaProportion distribution\n        (for direct sampling).\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    samples = m.dist.beta_proportion(mean=0.5, concentration=2.0, sample=True, shape=(1000,))\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#beta_proportion\n\n##### binomial { #BI.Utils.np_dists.UnifiedDist.binomial }\n\n```python\nUtils.np_dists.UnifiedDist.binomial(\n    total_count=1,\n    probs=None,\n    logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Binomial distribution.\n\nThe Binomial distribution models the number of successes in a sequence of independent Bernoulli trials.\nIt represents the probability of obtaining exactly *k* successes in *n* trials, where each trial has a probability *p* of success.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   P(X = k) = \\binom{n}{k} p^k (1-p)^{n-k}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    total_count (int): The number of trials *n*.\n\n- *probs* (jnp.ndarray, optional): The probability of success *p* for each trial. Must be between 0 and 1.\n\n    logits (jnp.ndarray, optional): The log-odds of success for each trial.  `probs = jax.nn.sigmoid(logits)`.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations.\n\n- *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    Binomial distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the Binomial distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.binomial(total_count=10, probs=0.5, sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#binomial\n\n##### binomial_logits { #BI.Utils.np_dists.UnifiedDist.binomial_logits }\n\n```python\nUtils.np_dists.UnifiedDist.binomial_logits(\n    logits,\n    total_count=1,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### BinomialLogits Distribution\n\n  The BinomialLogits distribution represents a binomial distribution parameterized by logits.\n  It is useful when the probability of success is not directly known but is instead\n  expressed as logits, which are the natural logarithm of the odds ratio.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      P(X=k) = \\binom{n}{k} \\frac{e^{logits_k}}{1 + e^{logits_k}}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      logits (jnp.ndarray): Log-odds of each success.\n      total_count (int): Number of trials.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the\n          distribution's batch shape. When `sample=True` (direct sampling), this\n          is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event\n          dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object\n          instead of creating a sample site. This is essential for building\n          complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro BinomialLogits distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the BinomialLogits distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.binomial_logits(logits=jnp.zeros(10), total_count=5, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#binomialllogits\n\n##### binomial_probs { #BI.Utils.np_dists.UnifiedDist.binomial_probs }\n\n```python\nUtils.np_dists.UnifiedDist.binomial_probs(\n    probs,\n    total_count=1,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### BinomialProbs\n\nSamples from a Binomial distribution with specified probabilities for each trial.\n\nThe Binomial distribution models the number of successes in a sequence of independent Bernoulli trials, where each trial has the same probability of success.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   P(k) = \\binom{n}{k} p^k (1-p)^{n-k}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *probs* (jnp.ndarray): The probability of success for each trial. Must be between 0 and 1.\n\n    total_count (int): The number of trials in each sequence.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro BinomialProbs distribution object (for model building).\n\n    JAX array of samples drawn from the BinomialProbs distribution (for direct sampling).\n\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.binomial_probs(probs=0.5, total_count=10, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#binomialprobs\n\n##### car { #BI.Utils.np_dists.UnifiedDist.car }\n\n```python\nUtils.np_dists.UnifiedDist.car(\n    loc,\n    correlation,\n    conditional_precision,\n    adj_matrix,\n    is_sparse=False,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Conditional Autoregressive (CAR) Distribution\n\nThe CAR distribution models a vector of variables where each variable is a linear\ncombination of its neighbors in a graph.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}        \n   p(x) = \\prod_{i=1}^{K} \\mathcal{N}(x_i | \\mu_i, \\Sigma_i)\n\\end{align*}\n```\n\n\n\n\n\n\nwhere :math:`\\mu_i` is a function of the values of the neighbors of site :math:`i`\nand :math:`\\Sigma_i` is the variance of site :math:`i`.\n\n.. note::\n\n   The CAR distribution is a special case of the multivariate normal distribution.\n   It is used to model spatial data, such as temperature or precipitation.\n\n\n#### Args:\n- *loc* (Union[float, Array]): Mean of the distribution.\n\n    correlation (Union[float, Array]): Correlation between variables.\n\n    conditional_precision (Union[float, Array]): Precision of the distribution.\n\n    adj_matrix (Union[Array, scipy.sparse.spmatrix]): Adjacency matrix defining the graph.\n    is_sparse (bool): Whether the adjacency matrix is sparse. Defaults to False.\n\n    validate_args (bool): Whether to validate arguments. Defaults to None.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n##### categorical { #BI.Utils.np_dists.UnifiedDist.categorical }\n\n```python\nUtils.np_dists.UnifiedDist.categorical(\n    probs=None,\n    logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Categorical distribution.\n\n  The Categorical distribution, also known as the multinomial distribution,\n  describes the probability of different outcomes from a finite set of possibilities.\n  It is commonly used to model discrete choices or classifications.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     P(k) = \\frac{e^{\\log(p_k)}}{\\sum_{j=1}^{K} e^{\\log(p_j)}}\n  \n  where :math:`p_k` is the probability of outcome :math:`k`, and the sum is over all possible outcomes.\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *probs* (jnp.ndarray): A 1D array of probabilities for each category. Must sum to 1.\n\n      Distribution #### Args:\n          None\n\n      Sampling / Modeling #### Args:\n      - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n              (model building), this is used with `.expand(shape)` to set the\n              distribution's batch shape. When `sample=True` (direct sampling),\n              this is used as `sample_shape` to draw a raw JAX array of the\n              given shape.\n\n      - *event* (int): The number of batch dimensions to reinterpret as event\n              dimensions (used in model building).\n\n      - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n      - *create_obj* (bool): If True, returns the raw NumPyro distribution\n              object instead of creating a sample site. This is essential for\n              building complex distributions like `MixtureSameFamily`.\n\n      - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n      - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n      - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n      - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Categorical distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Categorical distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.categorical(probs=jnp.array([0.2, 0.3, 0.5]), sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#categorical\n\n##### categorical_logits { #BI.Utils.np_dists.UnifiedDist.categorical_logits }\n\n```python\nUtils.np_dists.UnifiedDist.categorical_logits(\n    logits,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Categorical Logits Distribution\n\nSamples from a Categorical distribution with logits. This distribution represents a discrete probability distribution over a finite set of outcomes, where the probabilities are determined by the logits. The probability of each outcome is given by the softmax function applied to the logits.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    P(k) = \\frac{e^{logits_k}}{\\sum_{j=1}^{K} e^{logits_j}}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    logits (jnp.ndarray): Log-odds of each category.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro CategoricalLogits distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the CategoricalLogits distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.categorical_logits(logits=jnp.zeros(5), sample=True)\n\n#### Wrapper of:\nhttps://num.pyro.ai/en/stable/distributions.html#categoricallogits\n\n##### categorical_probs { #BI.Utils.np_dists.UnifiedDist.categorical_probs }\n\n```python\nUtils.np_dists.UnifiedDist.categorical_probs(\n    probs,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Categorical Probs distribution.\n\nSamples from a Categorical distribution.\n\nThe Categorical distribution is a discrete probability distribution that\nrepresents the probability of each outcome from a finite set of possibilities.\nIt is often used to model the outcome of a random process with a fixed number\nof possible outcomes, such as the roll of a die or the selection of an item\nfrom a list.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   P(x) = \\frac{probs_i}{\\sum_{k=1}^{K} probs_k}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *probs* (jnp.ndarray): Probabilities for each category. Must sum to 1.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n        (model building), this is used with `.expand(shape)` to set the\n        distribution's batch shape. When `sample=True` (direct sampling), this\n        is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions\n        (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object\n        instead of creating a sample site. This is essential for building\n        complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro CategoricalProbs distribution object (for model building).\n    JAX array of samples drawn from the CategoricalProbs distribution (for\n    direct sampling).\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.categorical_probs(probs=jnp.array([0.2, 0.3, 0.5]), sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#categoricalprobs\n\n##### cauchy { #BI.Utils.np_dists.UnifiedDist.cauchy }\n\n```python\nUtils.np_dists.UnifiedDist.cauchy(\n    loc=0.0,\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Cauchy Distribution\n\n  Samples from a Cauchy distribution.\n\n  The Cauchy distribution, also known as the Lorentz distribution, is a continuous probability distribution\n  that arises frequently in various fields, including physics and statistics. It is characterized by its\n  heavy tails, which extend indefinitely.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      f(x) = \\frac{1}{\\pi \\gamma} \\left[ \\frac{\\gamma^2}{(x - \\mu)^2 + \\gamma^2} \\right]\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *loc* (jnp.ndarray or float, optional): Location parameter.  Defaults to 0.0.\n  - *sample* (jnp.ndarray or float, optional): Scale parameter. Must be positive. Defaults to 1.0.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int, optional): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n          Defaults to None.\n\n  - *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations. Defaults to None.\n\n  - *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample\n          site. This is essential for building complex distributions like `MixtureSameFamily`. Defaults to False.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Cauchy distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Cauchy distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.cauchy(loc=0.0, scale=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#cauchy\n\n##### chi2 { #BI.Utils.np_dists.UnifiedDist.chi2 }\n\n```python\nUtils.np_dists.UnifiedDist.chi2(\n    df,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Chi-squared distribution.\n\nThe Chi-squared distribution is a continuous probability distribution that arises\nfrequently in hypothesis testing, particularly in ANOVA and chi-squared tests.\nIt is defined by a single positive parameter, degrees of freedom (df), which\ndetermines the shape of the distribution.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   p(x; df) = \\frac{1}{2^{df/2} \\Gamma(df/2)} x^{df/2 - 1} e^{-x/2}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    df (jnp.ndarray): Degrees of freedom. Must be positive.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n        (model building), this is used with `.expand(shape)` to set the\n        distribution's batch shape. When `sample=True` (direct sampling), this\n        is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event\n        dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object\n        instead of creating a sample site. This is essential for building\n        complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Chi2 distribution object (when `sample=False`).\n    JAX array of samples drawn from the Chi2 distribution (when `sample=True`).\n    The raw NumPyro distribution object (when `create_obj=True`).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu)\n    m.dist.chi2(df=3.0, sample = True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#chi2\n\n##### circulant_normal { #BI.Utils.np_dists.UnifiedDist.circulant_normal }\n\n```python\nUtils.np_dists.UnifiedDist.circulant_normal(\n    loc,\n    covariance_row=None,\n    covariance_rfft=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Circulant Normal Distribution\nMultivariate normal distribution with covariance matrix :math:`\\mathbf{C}` that is\npositive-definite and circulant [1], i.e., has periodic boundary conditions. The\ndensity of a sample :math:`\\mathbf{x}\\in\\mathbb{R}^n` is the standard multivariate\nnormal density\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n\n    p\\left(\\mathbf{x}\\mid\\boldsymbol{\\mu},\\mathbf{C}\\right) =\n    \\frac{\\left(\\mathrm{det}\\,\\mathbf{C}\\right)^{-1/2}}{\\left(2\\pi\\right)^{n / 2}}\n    \\exp\\left(-\\frac{1}{2}\\left(\\mathbf{x}-\\boldsymbol{\\mu}\\right)^\\intercal\n    \\mathbf{C}^{-1}\\left(\\mathbf{x}-\\boldsymbol{\\mu}\\right)\\right),\n\\end{align*}\n```\n\n\n\n\n\n\nwhere :math:`\\mathrm{det}` denotes the determinant and :math:`^\\intercal` the\ntranspose. Circulant matrices can be diagnolized efficiently using the discrete\nFourier transform [1], allowing the log likelihood to be evaluated in\n:math:`n \\log n` time for :math:`n` observations [2].\n\n:param loc: Mean of the distribution :math:`\\boldsymbol{\\mu}`.\n:param covariance_row: First row of the circulant covariance matrix\n    :math:`\\boldsymbol{C}`. Because of periodic boundary conditions, the covariance\n    matrix is fully determined by its first row (see\n    :func:`jax.scipy.linalg.toeplitz` for further details).\n:param covariance_rfft: Real part of the real fast Fourier transform of\n    :code:`covariance_row`, the first row of the circulant covariance matrix\n    :math:`\\boldsymbol{C}`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\nReferences:\n\n1. Wikipedia. (n.d.). Circulant matrix. Retrieved March 6, 2025, from\n   https://en.wikipedia.org/wiki/Circulant_matrix\n2. Wood, A. T. A., & Chan, G. (1994). Simulation of Stationary Gaussian Processes in\n   :math:`\\left[0, 1\\right]^d`. *Journal of Computational and Graphical Statistics*,\n   3(4), 409--432. https://doi.org/10.1080/10618600.1994.10474655\n\n##### delta { #BI.Utils.np_dists.UnifiedDist.delta }\n\n```python\nUtils.np_dists.UnifiedDist.delta(\n    v=0.0,\n    log_density=0.0,\n    event_dim=0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Delta distribution.\n\nThe Delta distribution, also known as a point mass distribution, assigns probability 1 to a single point and 0 elsewhere. It's useful for representing deterministic variables or as a building block for more complex distributions.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   P(x = v) = 1\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    v (jnp.ndarray): The location of the point mass.\n    log_density (float, optional): The log probability density of the point mass. This is primarily for creating distributions that are non-normalized or for specific advanced use cases. For a standard delta distribution, this should be 0. Defaults to 0.0.    \n    event_dim (int, optional): The number of rightmost dimensions of `v` to interpret as event dimensions. Defaults to 0.\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Delta distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the Delta distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.delta(v=0.0, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#delta\n\n##### dirichlet { #BI.Utils.np_dists.UnifiedDist.dirichlet }\n\n```python\nUtils.np_dists.UnifiedDist.dirichlet(\n    concentration,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Dirichlet\n\nSamples from a Dirichlet distribution.\n\nThe Dirichlet distribution is a multivariate generalization of the Beta distribution.\nIt is a probability distribution over a simplex, which is a set of vectors where each element is non-negative and sums to one.\nIt is often used as a prior distribution for categorical distributions.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   P(x_1, ..., x_K) = \\frac{\\Gamma(\\sum_{i=1}^K \\alpha_i)}{\\prod_{i=1}^K \\Gamma(\\alpha_i)} \\prod_{i=1}^K x_i^{\\alpha_i - 1}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    concentration (jnp.ndarray): The concentration parameter(s) of the Dirichlet distribution.\n        Must be a positive array.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n        this is used with `.expand(shape)` to set the distribution's batch shape.\n        When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n        This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Dirichlet distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the Dirichlet distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.dirichlet(concentration=jnp.array([1.0, 1.0, 1.0]), sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#dirichlet\n\n##### dirichlet_multinomial { #BI.Utils.np_dists.UnifiedDist.dirichlet_multinomial }\n\n```python\nUtils.np_dists.UnifiedDist.dirichlet_multinomial(\n    concentration,\n    total_count=1,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Dirichlet-Multinomial Distribution.\n\nCreates a Dirichlet-Multinomial compound distribution, which is a Multinomial\ndistribution with a Dirichlet prior on its probabilities. It is often used in\nBayesian statistics to model count data where the proportions of categories are\nuncertain.\n\nThe probability mass function is given by:\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    P(\\mathbf{x} | \\boldsymbol{\\alpha}, n) = \\frac{n!}{\\prod_{i=1}^k x_i!} \\frac{\\Gamma(\\sum_{i=1}^k \\alpha_i)}{\\Gamma(n + \\sum_{i=1}^k \\alpha_i)} \\prod_{i=1}^k \\frac{\\Gamma(x_i + \\alpha_i)}{\\Gamma(\\alpha_i)}\n\\end{align*}\n```\n\n\n\n\n\nwhere :math:`\\mathbf{x}` is a vector of counts, :math:`n` is the total number of\ntrials (`total_count`), and :math:`\\boldsymbol{\\alpha}` is the `concentration`\nparameter vector for the Dirichlet prior.\n\n#### Args:\n    concentration (jnp.ndarray): The concentration parameter (alpha) for the Dirichlet prior. Values must be positive. The last dimension is interpreted as the number of categories.\n    total_count (int, jnp.ndarray, optional): The total number of trials (n). This must be a non-negative integer. Defaults to 1.\n    validate_args (bool, optional): Whether to enable validation of distribution parameters. Defaults to `None`.\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations. If provided, events with a `True` mask will be conditioned on `obs`, while the remaining events will be treated as latent variables. Defaults to `None`.\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. This argument has no effect when `sample=False`. Defaults to 0.\n\n- *shape* (tuple, optional): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int, optional): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`. Defaults to `False`.\n\n#### Returns:\n    numpyro.primitives.Messenger: A NumPyro sample site object when used in a model context (`sample=False`).\n    jnp.ndarray: A JAX array of samples drawn from the Dirichlet-Multinomial distribution (for direct sampling, `sample=True`).\n    numpyro.distributions.Distribution: The raw NumPyro distribution object (if `create_obj=True`).\n\n#### Example Usage:\n    from BI import bi\n    import jax.numpy as jnp\n    m = bi('cpu')\n\n    # Direct sampling\n    # Sample a single vector of counts for 10 trials from 3 categories\n    counts = m.dist.dirichlet_multinomial(concentration=jnp.array([1.0, 1.0, 1.0]),total_count=10,sample=True)\n\n    # Usage within a model\n    def my_model(obs_data=None):\n        # Define a prior on the concentration parameter\n        alpha = m.dist.half_cauchy(scale=jnp.ones(5), name='alpha', shape=(5,))\n\n        # Model observed counts\n        with m.plate('data', len(obs_data)):\n            y = m.dist.dirichlet_multinomial(\n                concentration=alpha,\n                total_count=100,\n                name='y',\n                obs=obs_data\n            )\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#dirichletmultinomial\n\n##### discrete_uniform { #BI.Utils.np_dists.UnifiedDist.discrete_uniform }\n\n```python\nUtils.np_dists.UnifiedDist.discrete_uniform(\n    low=0,\n    high=1,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Discrete Uniform Distribution\n\n  Samples from a Discrete Uniform distribution.\n\n  The Discrete Uniform distribution defines a uniform distribution over a range of integers.\n  It is characterized by a lower bound (`low`) and an upper bound (`high`), inclusive.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     P(X = k) = \\frac{1}{high - low + 1}, \\quad k \\in \\{low, low+1, ..., high\\}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      low (jnp.ndarray): The lower bound of the uniform range, inclusive.\n      high (jnp.ndarray): The upper bound of the uniform range, inclusive.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n          JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a\n          sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro DiscreteUniform distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Discrete Uniform distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.discrete_uniform(low=0, high=5, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#discreteuniform\n\n##### doubly_truncated_power_law { #BI.Utils.np_dists.UnifiedDist.doubly_truncated_power_law }\n\n```python\nUtils.np_dists.UnifiedDist.doubly_truncated_power_law(\n    alpha,\n    low,\n    high,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Doubly Truncated Power Law distribution.\n\nThis distribution represents a continuous power law with a finite support bounded\nbetween `low` and `high`, and with an exponent `alpha`. It is normalized over the\ninterval `[low, high]` to ensure the area under the density function is 1.\n\nThe probability density function (PDF) is defined as:\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x; \\\\alpha, a, b) = \\\\frac{x^{\\\\alpha}}{Z(\\\\alpha, a, b)}\n\\end{align*}\n```\n\n\n\n\n\nwhere the normalization constant :math:`Z(\\\\alpha, a, b)` is given by:\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    Z(\\\\alpha, a, b) = \\\\begin{cases}\n        \\\\log(b) - \\\\log(a) & \\\\text{if } \\\\alpha = -1, \\\\\\\\\n        \\\\frac{b^{1 + \\\\alpha} - a^{1 + \\\\alpha}}{1 + \\\\alpha} & \\\\text{otherwise}.\n    \\\\end{cases}\n\\end{align*}\n```\n\n\n\n\n\nThis distribution is useful for modeling data that follows a power-law behavior\nbut is naturally bounded due to measurement or theoretical constraints (e.g.,\nfinite-size systems).\n\n\n#### Args:\n    alpha (float or array-like): Power-law exponent.\n\n    low (float or array-like): Lower bound of the distribution (must be â‰¥ 0).\n\n    high (float or array-like): Upper bound of the distribution (must be > 0).\n\n- *shape* (tuple, optional): The shape of the output tensor. Defaults to None.\n\n    validate_args (bool, optional): Whether to validate the arguments. Defaults to True.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')        \n    m.dist.doubly_truncated_power_law(low=0.1, high=10.0, alpha=2.0, sample=True)\n\n##### euler_maruyama { #BI.Utils.np_dists.UnifiedDist.euler_maruyama }\n\n```python\nUtils.np_dists.UnifiedDist.euler_maruyama(\n    t,\n    sde_fn,\n    init_dist,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n###  Eulerâ€“Maruyama Distribution\nEulerâ€“Maruyama methode is a method for the approximate numerical solution\nof a stochastic differential equation (SDE). It simulates the solution\nto an SDE by iteratively applying the Euler method to each time step,\nincorporating a random perturbation to account for the diffusion term.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    dX_t = f(X_t, t) dt + g(X_t, t) dW_t\n\\end{align*}\n```\n\n\n\n\n\nwhere:\n- :math:`X_t` is the state of the system at time :math:`t`.\n- :math:`f(X_t, t)` is the drift coefficient.\n- :math:`g(X_t, t)` is the diffusion coefficient.\n- :math:`dW_t` is a Wiener process (Brownian motion).\n\n\n#### Args:\n    t (jnp.ndarray): Discretized time steps.\n\n    sde_fn (callable): A function that takes the current state and time as input and returns the drift and diffusion coefficients.\n    init_dist (Distribution): The initial distribution of the system.\n\n- *shape* (tuple, optional): The shape of the output tensor. Defaults to None.\n\n    sample_shape (tuple, optional): The shape of the samples to draw. Defaults to None.\n\n    validate_args (bool, optional): Whether to validate the arguments. Defaults to True.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    jnp.ndarray: Samples drawn from the Eulerâ€“Maruyama distribution.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.euler_maruyama(t=jnp.array([0.0, 0.1, 0.2]), sde_fn=lambda x, t: (x, 1.0), init_dist=m.dist.normal(0.0, 1.0, create_obj=True), sample = True)\n\n##### exponential { #BI.Utils.np_dists.UnifiedDist.exponential }\n\n```python\nUtils.np_dists.UnifiedDist.exponential(\n    rate=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Exponential distribution.\n\n  The Exponential distribution is a continuous probability distribution that models the time until an event occurs in a Poisson process, where events occur continuously and independently at a constant average rate. It is often used to model the duration of events, such as the time until a machine fails or the length of a phone call.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     f(x) = \\lambda e^{-\\lambda x} \\text{ for } x \\geq 0\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      rate (jnp.ndarray): The rate parameter, :math:`\\lambda`. Must be positive.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Exponential distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Exponential distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.exponential(rate=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#exponential\n\n##### folded_distribution { #BI.Utils.np_dists.UnifiedDist.folded_distribution }\n\n```python\nUtils.np_dists.UnifiedDist.folded_distribution(\n    base_dist,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Folded distribution\n\nSamples from a Folded distribution, which is the absolute value of a base univariate distribution.\nThis distribution reflects the base distribution across the origin, effectively taking the absolute value of each sample.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    p(x) = \\sum_{k=-\\infty}^{\\infty} p(x - 2k)\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *loc* (float, optional): Location parameter of the base distribution. Defaults to 0.0.\n- *sample* (float, optional): Scale parameter of the base distribution. Defaults to 1.0.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n        with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n        used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n        This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro FoldedDistribution distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the FoldedDistribution distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.folded_distribution(m.dist.normal(loc=0.0, scale=1.0, create_obj = True), sample=True)\n\n#### Wrapper of:\nhttps://num.pyro.ai/en/stable/distributions.html#foldeddistribution\n\n##### gamma { #BI.Utils.np_dists.UnifiedDist.gamma }\n\n```python\nUtils.np_dists.UnifiedDist.gamma(\n    concentration,\n    rate=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Gamma Distribution\n\nSamples from a Gamma distribution.\n\nThe Gamma distribution is a continuous probability distribution that arises frequently in Bayesian statistics,\nparticularly in prior distributions for variance parameters. It is defined by two positive shape parameters,\nconcentration (k) and rate (theta).\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} x^{\\alpha-1} e^{-\\beta x}, \\quad x > 0\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    concentration (jnp.ndarray): The shape parameter of the Gamma distribution (k > 0).\n\n    rate (jnp.ndarray): The rate parameter of the Gamma distribution (theta > 0).\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n        with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n        used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n        This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    Gamma: A NumPyro Gamma distribution object (for model building).\n\n    jnp.ndarray: A JAX array of samples drawn from the Gamma distribution (for direct sampling).\n\n    Gamma: The raw NumPyro distribution object (for advanced use cases).\n\n\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.gamma(concentration=2.0, rate=0.5, sample=True)\n\n#### Wrapper of:\nhttps://num.pyro.ai/en/stable/distributions.html#gamma\n\n##### gamma_poisson { #BI.Utils.np_dists.UnifiedDist.gamma_poisson }\n\n```python\nUtils.np_dists.UnifiedDist.gamma_poisson(\n    concentration,\n    rate=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### GammaPoisson Distribution\n\n  A compound distribution comprising of a gamma-poisson pair, also referred to as\n  a gamma-poisson mixture. The ``rate`` parameter for the\n  :class:`~numpyro.distributions.Poisson` distribution is unknown and randomly\n  drawn from a :class:`~numpyro.distributions.Gamma` distribution.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     P(X = x) = \\int_0^\\infty \\frac{1}{x} \\exp(-x \\lambda) \\frac{1}{\\Gamma(\\alpha)} x^{\\alpha - 1} e^{-x \\beta} dx\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      concentration (jnp.ndarray): Shape parameter (alpha) of the Gamma distribution.\n      rate (jnp.ndarray): Rate parameter (beta) for the Gamma distribution.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the\n          distribution's batch shape. When `sample=True` (direct sampling), this\n          is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event\n          dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object\n          instead of creating a sample site. This is essential for building\n          complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro GammaPoisson distribution object (for model\n          building).\n\n- When `sample=True`: A JAX array of samples drawn from the GammaPoisson\n          distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced\n          use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.gamma_poisson(concentration=1.0, rate=2.0, sample=True)\n\n  #### Wrapper of:\n  https://num.pyro.ai/en/stable/distributions.html#gammapoisson\n\n##### gaussian_copula { #BI.Utils.np_dists.UnifiedDist.gaussian_copula }\n\n```python\nUtils.np_dists.UnifiedDist.gaussian_copula(\n    marginal_dist,\n    correlation_matrix=None,\n    correlation_cholesky=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n###  Gaussian Copula Distribution\n\nA distribution that links the `batch_shape[:-1]` of a marginal distribution with a multivariate Gaussian copula,\nmodelling the correlation between the axes. A copula is a multivariate distribution over the uniform distribution\non [0, 1]. The Gaussian copula links the marginal distributions through a multivariate normal distribution.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x_1, ..., x_d) = \\prod_{i=1}^{d} f_i(x_i) \\cdot \\phi(F_1(x_1), ..., F_d(x_d); \\mu, \\Sigma)\n\\end{align*}\n```\n\n\n\n\n\n\nwhere:\n- $f_i$ is the probability density function of the i-th marginal distribution.\n- $F_i$ is the cumulative distribution function of the i-th marginal distribution.\n- $\\phi$ is the standard normal PDF.\n- $\\mu$ is the mean vector of the multivariate normal distribution.\n- $\\Sigma$ is the covariance matrix of the multivariate normal distribution.\n\n\n#### Args:\n    marginal_dist (Distribution): Distribution whose last batch axis is to be coupled.\n\n    correlation_matrix (array_like, optional): Correlation matrix of the coupling multivariate normal distribution. Defaults to None.\n\n    correlation_cholesky (array_like, optional): Correlation Cholesky factor of the coupling multivariate normal distribution. Defaults to None.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations. Defaults to None.\n\n- *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `Mi  xtureSameFamily`. Defaults to False.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro GaussianCopula distribution object: When `sample=False` (for model building).\n    JAX array: When `sample=True` (for direct sampling).\n    NumPyro distribution object: When `create_obj=True` (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.gaussian_copula(\n        marginal_dist = m.dist.beta(2.0, 5.0, create_obj = True), \n        correlation_matrix = jnp.array([[1.0, 0.7],[0.7, 1.0]]), \n        sample = True\n    )\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#gaussiancopula\n\n##### gaussian_copula_beta { #BI.Utils.np_dists.UnifiedDist.gaussian_copula_beta }\n\n```python\nUtils.np_dists.UnifiedDist.gaussian_copula_beta(\n    concentration1,\n    concentration0,\n    correlation_matrix=None,\n    correlation_cholesky=None,\n    validate_args=False,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Gaussian Copula Beta distribution.\n\nThis distribution combines a Gaussian copula with a Beta distribution.\nThe Gaussian copula models the dependence structure between random variables,\nwhile the Beta distribution defines the marginal distributions of each variable.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x) = \\int_{-\\infty}^{\\infty} g(x|u) h(u) du\n\\end{align*}\n```\n\n\n\n\n\n\nWhere:\n    - g(x|u) is the Gaussian copula density.\n    - h(u) is the Beta density.\n\n#### Args:\n    concentration1 (jnp.ndarray): The first shape parameter of the Beta distribution.\n\n    concentration0 (jnp.ndarray): The second shape parameter of the Beta distribution.\n\n    correlation_matrix (array_like, optional): Correlation matrix of the coupling multivariate normal distribution. Defaults to None.\n\n    correlation_cholesky (jnp.ndarray): The Cholesky decomposition of the correlation matrix.\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n        this is used with `.expand(shape)` to set the distribution's batch shape.\n        When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array\n        of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample\n        site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    GaussianCopulaBeta: A NumPyro GaussianCopulaBeta distribution object (for model building).\n    jnp.ndarray: A JAX array of samples drawn from the GaussianCopulaBeta distribution (for direct sampling).\n    Distribution: The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.gaussian_copula_beta(\n        concentration1 = jnp.array([2.0, 3.0]), \n        concentration0 = jnp.array([5.0, 3.0]),\n        correlation_cholesky = jnp.linalg.cholesky(jnp.array([[1.0, 0.7],[0.7, 1.0]])), \n        sample = True\n    )\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#gaussiancopulabetadistribution\n\n##### gaussian_random_walk { #BI.Utils.np_dists.UnifiedDist.gaussian_random_walk }\n\n```python\nUtils.np_dists.UnifiedDist.gaussian_random_walk(\n    scale=1.0,\n    num_steps=1,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Gaussian Random Walk Distribution.\n\nCreates a distribution over a Gaussian random walk of a specified number of steps.\nThis is a discrete-time stochastic process where the value at each step is the\nprevious value plus a Gaussian-distributed increment. The distribution is over\nthe entire path.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    X_t = X_{t-1} + \\epsilon_t, \\quad \\text{where} \\quad \\epsilon_t \\sim \\mathcal{N}(0, \\sigma^2)\n\\end{align*}\n```\n\n\n\n\n\nwith the initial state :math:`X_0 = 0`. The resulting sample is a vector of\nlength `num_steps`, representing the path :math:`(X_1, X_2, \\dots, X_{\\text{num\\_steps}})`.\n\n#### Args:\n- *sample* (float, jnp.ndarray, optional): The standard deviation (:math:`\\sigma`) of the Gaussian increments. Must be positive. Defaults to 1.0.\n    num_steps (int, optional): The number of steps in the random walk, which determines the event shape of the distribution. Must be positive. Defaults to 1.\n    validate_args (bool, optional): Whether to enable validation of distribution parameters. Defaults to `None`.\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n- *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations. If provided, events with a `True` mask will be conditioned on `obs`, while the remaining events will be treated as latent variables. Defaults to `None`.\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. This argument has no effect when `sample=False`. Defaults to 0.\n- *shape* (tuple, optional): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n- *event* (int, optional): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n- *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`. Defaults to `False`.\n\n#### Returns:\n    numpyro.primitives.Messenger: A NumPyro sample site object when used in a model context (`sample=False`).\n    jnp.ndarray: A JAX array of samples drawn from the GaussianRandomWalk distribution (for direct sampling, `sample=True`).\n    numpyro.distributions.Distribution: The raw NumPyro distribution object (if `create_obj=True`).\n\n#### Example Usage:\n    from BI import bi\n    import jax.numpy as jnp\n    m = bi('cpu')\n\n    # Direct sampling of a random walk with 100 steps\n    path = m.dist.gaussian_random_walk(scale=0.5, num_steps=100, sample=True)\n\n    # Usage within a model for a latent time series\n    def my_model(data=None):\n        # Prior on the volatility of the random walk\n        volatility = m.dist.half_cauchy(scale=1.0, name='volatility')\n\n        # The latent random walk\n        latent_process = m.dist.gaussian_random_walk(\n            scale=volatility,\n            num_steps=len(data) if data is not None else 10,\n            name='latent_process'\n        )\n\n        # Observation model\n        # Assumes the observed data is the latent process plus some noise\n        obs_noise = m.dist.half_cauchy(scale=1.0, name='obs_noise')\n        with m.plate('time', len(data) if data is not None else 10):\n            return m.dist.normal(loc=latent_process, scale=obs_noise, obs=data, name='obs')\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#gaussianrandomwalk\n\n##### gaussian_state_space { #BI.Utils.np_dists.UnifiedDist.gaussian_state_space }\n\n```python\nUtils.np_dists.UnifiedDist.gaussian_state_space(\n    num_steps,\n    transition_matrix,\n    covariance_matrix=None,\n    precision_matrix=None,\n    scale_tril=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Gaussian State Space Distribution\n\n  Samples from a Gaussian state space model.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      \\mathbf{z}_{t} &= \\mathbf{A} \\mathbf{z}_{t - 1} + \\boldsymbol{\\epsilon}_t\\\\\n      &=\\sum_{k=1} \\mathbf{A}^{t-k} \\boldsymbol{\\epsilon}_t,\n  \\end{align*}\n  ```        \n\n\n\n\n\n  where :math:`\\mathbf{z}_t` is the state vector at step :math:`t`, :math:`\\mathbf{A}`\n  is the transition matrix, and :math:`\\boldsymbol\\epsilon` is the innovation noise.\n\n\n  #### Args:\n      num_steps (int): Number of steps.\n\n      transition_matrix (jnp.ndarray): State space transition matrix :math:`\\mathbf{A}`.\n\n      covariance_matrix (jnp.ndarray, optional): Covariance of the innovation noise\n          :math:`\\boldsymbol{\\epsilon}`. Defaults to None.\n\n      precision_matrix (jnp.ndarray, optional): Precision matrix of the innovation noise\n          :math:`\\boldsymbol{\\epsilon}`. Defaults to None.\n\n      scale_tril (jnp.ndarray, optional): Scale matrix of the innovation noise\n          :math:`\\boldsymbol{\\epsilon}`. Defaults to None.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`  (model building), this is used   with `.expand(shape)` to set the distribution's     batch shape. When `sample=True` (direct sampling), this is    used as `sample_shape`    to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions    (used in model building).\n\n  - *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations. Defaults to None.\n\n  - *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. Defaults to False.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro GaussianStateSpace distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the GaussianStateSpace distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.gaussian_state_space(num_steps=5, transition_matrix=jnp.array([[0.5]]), covariance_matrix =  jnp.array([[1.0, 0.6],[0.6, 1.0]]), sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#gaussianstate\n\n##### geometric { #BI.Utils.np_dists.UnifiedDist.geometric }\n\n```python\nUtils.np_dists.UnifiedDist.geometric(\n    probs=None,\n    logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Geometric distribution.\n\n  The Geometric distribution models the number of failures before the first success in a sequence of Bernoulli trials.\n  It is characterized by a single parameter, the probability of success on each trial.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     P(X = k) = (1 - p)^k p\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *probs* (jnp.ndarray, optional): Probability of success on each trial. Must be between 0 and 1.\n      logits (jnp.ndarray, optional): Log-odds of success on each trial.  `probs = jax.nn.sigmoid(logits)`.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations.\n\n  - *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Geometric distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Geometric distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.geometric(probs=0.5, sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#geometric\n\n##### geometric_logits { #BI.Utils.np_dists.UnifiedDist.geometric_logits }\n\n```python\nUtils.np_dists.UnifiedDist.geometric_logits(\n    logits,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### GeometricLogits Distribution\n\nSamples from a GeometricLogits distribution, which models the number of failures before the first success in a sequence of independent Bernoulli trials.  It is parameterized by logits, which are transformed into probabilities using the sigmoid function.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    P(X = k) = (1 - p)^k p\n\\end{align*}\n```        \n\n\n\n\n\nwhere:\n\n*   X is the number of failures before the first success.\n*   k is the number of failures.\n*   p is the probability of success on each trial (derived from the logits).\n\n#### Args:\n    logits (jnp.ndarray): Log-odds parameterization of the probability of success.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro GeometricLogits distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the GeometricLogits distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.geometric_logits(logits=jnp.zeros(10), sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#geometriclogits\n\n##### geometric_probs { #BI.Utils.np_dists.UnifiedDist.geometric_probs }\n\n```python\nUtils.np_dists.UnifiedDist.geometric_probs(\n    probs,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### GeometricProbs\n\nSamples from a Geometric distribution.\n\nThe Geometric distribution models the number of trials until the first success in a sequence of independent Bernoulli trials, where each trial has the same probability of success.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    P(X = k) = (1 - p)^k p\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *probs* (jnp.ndarray): Probability of success on each trial. Must be between 0 and 1.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro GeometricProbs distribution object (for model building).\n    JAX array of samples drawn from the GeometricProbs distribution (for direct sampling).\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.geometric_probs(probs=0.5, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#geometricprobs\n\n##### gompertz { #BI.Utils.np_dists.UnifiedDist.gompertz }\n\n```python\nUtils.np_dists.UnifiedDist.gompertz(\n    concentration,\n    rate=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Gompertz Distribution.\n\nThe Gompertz distribution is a distribution with support on the positive real line that is closely\nrelated to the Gumbel distribution. This implementation follows the notation used in the Wikipedia\nentry for the Gompertz distribution. See https://en.wikipedia.org/wiki/Gompertz_distribution.\n\nThe probability density function (PDF) is:\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x) = \\frac{con}{rate} \\exp \\left\\{ - \\frac{con}{rate} \\left [ \\exp\\{x * rate \\} - 1 \\right ] \\right\\} \\exp(-x * rate)\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    concentration (jnp.ndarray): The concentration parameter. Must be positive.\n    rate (jnp.ndarray): The rate parameter. Must be positive.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n        with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n        used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n        This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Gompertz distribution object: When `sample=False` (for model building).\n    JAX array: When `sample=True` (for direct sampling).\n    NumPyro distribution object: When `create_obj=True` (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.gompertz(concentration=1.0, rate=1.0, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#gompertz\n\n##### gumbel { #BI.Utils.np_dists.UnifiedDist.gumbel }\n\n```python\nUtils.np_dists.UnifiedDist.gumbel(\n    loc=0.0,\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Gumbel\n\n  Samples from a Gumbel (or Extreme Value) distribution.\n\n  The Gumbel distribution is a continuous probability distribution named after German mathematician Carl Gumbel.\n  It is often used to model the distribution of maximum values in a sequence of independent random variables.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     f(x) = \\frac{1}{s} e^{-(x - \\mu) / s} e^{-e^{- (x - \\mu) / s}}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *loc* (jnp.ndarray or float, optional): Location parameter. Defaults to 0.0.\n  - *sample* (jnp.ndarray or float, optional): Scale parameter. Must be positive. Defaults to 1.0.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int, optional): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n          Defaults to 1.\n\n  - *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations. Defaults to None.\n\n  - *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample\n          site. This is essential for building complex distributions like `MixtureSameFamily`. Defaults to False.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Gumbel distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Gumbel distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.gumbel(loc=0.0, scale=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#gumbel\n\n##### half_cauchy { #BI.Utils.np_dists.UnifiedDist.half_cauchy }\n\n```python\nUtils.np_dists.UnifiedDist.half_cauchy(\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### HalfCauchy Distribution\n\n  The HalfCauchy distribution is a probability distribution that is half of the Cauchy distribution. It is defined on the positive real numbers and is often used in situations where only positive values are relevant.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     f(x) = \\frac{1}{2} \\cdot \\frac{1}{\\pi \\cdot \\frac{1}{scale} \\cdot (x^2 + \\frac{1}{scale^2})}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *sample* (jnp.ndarray): The scale parameter of the Cauchy distribution. Must be positive.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro HalfCauchy distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the HalfCauchy distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.half_cauchy(scale=1.0, sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#halfcauchy\n\n##### half_normal { #BI.Utils.np_dists.UnifiedDist.half_normal }\n\n```python\nUtils.np_dists.UnifiedDist.half_normal(\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### HalfNormal\n\n  Samples from a HalfNormal distribution.\n\n  The HalfNormal distribution is a distribution of the absolute value of a normal random variable.\n  It is defined by a location parameter (implicitly 0) and a scale parameter.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{x^2}{2\\sigma^2}} \\text{ for } x > 0\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *sample* (float, array): The scale parameter of the distribution. Must be positive.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n          JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a\n          sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro HalfNormal distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the HalfNormal distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.half_normal(scale=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#halfnormal\n\n##### improper_uniform { #BI.Utils.np_dists.UnifiedDist.improper_uniform }\n\n```python\nUtils.np_dists.UnifiedDist.improper_uniform(\n    support,\n    batch_shape,\n    event_shape,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Improper Uniform Distribution\n\n  A helper distribution with zero :meth:`log_prob` over the `support` domain.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     p(x) = 0\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      support (numpyro.distributions.constraints.Constraint): The support of this distribution.\n\n      batch_shape (tuple): Batch shape of this distribution. It is usually safe to\n          set `batch_shape=()`.\n\n      event_shape (tuple): Event shape of this distribution.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the\n          distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions\n          (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object\n          instead of creating a sample site. This is essential for building\n          complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro ImproperUniform distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the ImproperUniform distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from numpyro import sample\n      from numpyro.distributions import ImproperUniform, Normal, constraints\n\n      def model():\n          x = sample('x', ImproperUniform(constraints.ordered_vector, (), event_shape=(10,)))\n\n      #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#improperuniform\n\n##### inverse_gamma { #BI.Utils.np_dists.UnifiedDist.inverse_gamma }\n\n```python\nUtils.np_dists.UnifiedDist.inverse_gamma(\n    concentration,\n    rate=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Inverse Gamma Distribution\n\n  The InverseGamma distribution is a two-parameter family of continuous probability\n  distributions. It is defined by its shape and rate parameters. It is often used as a prior distribution for\n  precision parameters (inverse variance) in Bayesian statistics.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      p(x) = \\frac{1}{Gamma(\\alpha)} \\left( \\frac{\\beta}{\\Gamma(\\alpha)} \\right)^{\\alpha} x^{\\alpha - 1} e^{-\\beta x}\n      \\text{ for } x > 0\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      concentration (jnp.ndarray): The shape parameter (\\\\alpha) of the InverseGamma distribution. Must be positive.\n      rate (jnp.ndarray): The rate parameter (\\\\beta) of the InverseGamma distribution. Must be positive.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro InverseGamma distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the InverseGamma distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.inverse_gamma(concentration=2.0, rate=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#inversegamma\n\n##### kumaraswamy { #BI.Utils.np_dists.UnifiedDist.kumaraswamy }\n\n```python\nUtils.np_dists.UnifiedDist.kumaraswamy(\n    concentration1,\n    concentration0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Kumaraswamy Distribution.\n\n  The Kumaraswamy distribution is a continuous probability distribution defined on the interval [0, 1].\n  It is a flexible distribution that can take on various shapes depending on its parameters.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      f(x; a, b) = a b x^{a b - 1} (1 - x)^{b - 1}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      concentration1 (jnp.ndarray): The first shape parameter. Must be positive.\n      concentration0 (jnp.ndarray): The second shape parameter. Must be positive.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Kumaraswamy distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Kumaraswamy distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.kumaraswamy(concentration1=2.0, concentration0=3.0, sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#kumaraswamy\n\n##### laplace { #BI.Utils.np_dists.UnifiedDist.laplace }\n\n```python\nUtils.np_dists.UnifiedDist.laplace(\n    loc=0.0,\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Laplace Distribution\n\n  Samples from a Laplace distribution, also known as the double exponential distribution.\n  The Laplace distribution is defined by its location parameter (loc) and scale parameter (scale).\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     f(x) = \\frac{1}{2s} \\exp\\left(-\\frac{|x - \\mu|}{s}\\right)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *loc* (jnp.ndarray): Location parameter of the Laplace distribution.\n\n  - *sample* (jnp.ndarray): Scale parameter of the Laplace distribution. Must be positive.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n          JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a\n          sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Laplace distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Laplace distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.laplace(loc=0.0, scale=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#laplace\n\n##### left_truncated_distribution { #BI.Utils.np_dists.UnifiedDist.left_truncated_distribution }\n\n```python\nUtils.np_dists.UnifiedDist.left_truncated_distribution(\n    base_dist,\n    low=0.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Left Truncated Distribution\n\n  Samples from a left-truncated distribution.\n\n  A left-truncated distribution is a probability distribution\n  obtained by restricting the support of another distribution\n  to values greater than a specified lower bound. This is useful\n  when dealing with data that is known to be greater than a certain value.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     f(x) = \\begin{cases}\n             \\frac{f(x)}{P(X > \\text{low})} & \\text{if } x > \\text{low} \\\\\n             0 & \\text{otherwise}\n             \\end{cases}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      base_dist: The base distribution to truncate. Must be univariate and have real support.\n      low: The lower truncation bound. Values less than this are excluded from the distribution.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n          JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro LeftTruncatedDistribution distribution object (for model building).\n\n- When `sample=True`: A JAX array of samples drawn from the LeftTruncatedDistribution distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#lefttruncateddistribution\n\n##### levy { #BI.Utils.np_dists.UnifiedDist.levy }\n\n```python\nUtils.np_dists.UnifiedDist.levy(\n    loc,\n    scale,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Levy distribution.\n\nSamples from a Levy distribution.\n\nThe probability density function is given by,\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x\\mid \\mu, c) = \\sqrt{\\frac{c}{2\\pi(x-\\mu)^{3}}} \\exp\\left(-\\frac{c}{2(x-\\mu)}\\right), \\qquad x > \\mu\n\\end{align*}\n```        \n\n\n\n\n\nwhere :math:`\\mu` is the location parameter and :math:`c` is the scale parameter.\n\n\n#### Args:\n- *loc* (jnp.ndarray): Location parameter.\n- *sample* (jnp.ndarray): Scale parameter.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`  (model building), this is used   with `.expand(shape)` to set the distribution's     batch shape. When `sample=True` (direct sampling), this is    used as `sample_shape`    to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions    (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Levy distribution object: When `sample=False` (for model building).\n    JAX array: When `sample=True` (for direct sampling).\n    NumPyro distribution object: When `create_obj=True` (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.levy(loc=0.0, scale=1.0, sample=True)\n\n#### Wrapper of:\nhttps://num.pyro.ai/en/stable/distributions.html#levy\n\n##### lkj { #BI.Utils.np_dists.UnifiedDist.lkj }\n\n```python\nUtils.np_dists.UnifiedDist.lkj(\n    dimension,\n    concentration=1.0,\n    sample_method='onion',\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Lewandowski Kurowicka Joe distribution \n\n  The LKJ distribution is controlled by the concentration parameter :math:`\\eta` to make the probability\n  of the correlation matrix :math:`M` proportional to :math:`\\det(M)^{\\eta - 1}`. When :math:`\\eta = 1`,\n  the distribution is uniform over correlation matrices.  When :math:`\\eta > 1`, the distribution favors\n  samples with large determinants. When :math:`\\eta < 1`, the distribution favors samples with small\n  determinants.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      P(M) \\propto |\\det(M)|^{\\eta - 1}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      dimension (int): The dimension of the correlation matrices.\n\n      concentration (ndarray): The concentration/shape parameter of the distribution (often referred to as eta). Must be positive.\n\n      sample_method (str): Either â€œcvineâ€ or â€œonionâ€. Both methods are proposed in [1] and offer the same distribution over correlation matrices. But they are different in how to generate samples. Defaults to â€œonionâ€.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this\n          is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro LKJ distribution object (for model building).\n\n- When `sample=True`: A JAX array of samples drawn from the LKJ distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.lkj(dimension=2, concentration=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#lkj\n\n##### lkj_cholesky { #BI.Utils.np_dists.UnifiedDist.lkj_cholesky }\n\n```python\nUtils.np_dists.UnifiedDist.lkj_cholesky(\n    dimension,\n    concentration=1.0,\n    sample_method='onion',\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### LKJ Cholesky Distribution\n\nThe LKJ (Leonard-KjÃ¦rgaard-JÃ¸rgensen) Cholesky distribution is a family of distributions\non symmetric matrices, often used as a prior for the Cholesky decomposition of a\nsymmetric matrix. It is particularly useful in Bayesian inference for models with\ncovariance structure.\n\\end{align*}\n```\n\n#### Args:\n    dimension (int): The dimension of the correlation matrices.\n\n    concentration (float): A parameter controlling the concentration of the distribution\n        around the identity matrix. Higher values indicate greater concentration.\n        Must be greater than 1.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n        with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this\n        is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n        This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n    \n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n    \nAttributes:\n    concentration (float): The concentration parameter.\n\n##### log_normal { #BI.Utils.np_dists.UnifiedDist.log_normal }\n\n```python\nUtils.np_dists.UnifiedDist.log_normal(\n    loc=0.0,\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### LogNormal distribution.\n\nThe LogNormal distribution is a probability distribution defined for positive real-valued random variables,\nparameterized by a location parameter (loc) and a scale parameter (scale).  It arises when the logarithm\nof a random variable is normally distributed.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   f(x) = \\frac{1}{x \\sigma \\sqrt{2\\pi}} e^{-\\frac{(log(x) - \\mu)^2}{2\\sigma^2}}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *loc* (float): Location parameter.\n- *sample* (float): Scale parameter.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n        this is used with `.expand(shape)` to set the distribution's batch shape.\n        When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array\n        of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample\n        site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro LogNormal distribution object (for model building).\n    JAX array of samples drawn from the LogNormal distribution (for direct sampling).\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.log_normal(loc=0.0, scale=1.0, sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#lognormal\n\n##### log_uniform { #BI.Utils.np_dists.UnifiedDist.log_uniform }\n\n```python\nUtils.np_dists.UnifiedDist.log_uniform(\n    low,\n    high,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### LogUniform\n\nSamples from a LogUniform distribution.\n\nThe LogUniform distribution is defined over the positive real numbers and is the result of applying an exponential transformation to a uniform distribution over the interval [low, high]. It is often used when modeling parameters that must be positive.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   f(x) = \\frac{1}{(high - low) \\log(high / low)}\n   \\text{ for } low \\le x \\le high\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    low (jnp.ndarray): The lower bound of the uniform distribution's log-space. Must be positive.\n\n    high (jnp.ndarray): The upper bound of the uniform distribution's log-space. Must be positive.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro LogUniform distribution object (for model building) when `sample=False`.\n\n    JAX array of samples drawn from the LogUniform distribution (for direct sampling) when `sample=True`.\n\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.log_uniform(low=0.1, high=10.0, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#loguniform\n\n##### logistic { #BI.Utils.np_dists.UnifiedDist.logistic }\n\n```python\nUtils.np_dists.UnifiedDist.logistic(\n    loc=0.0,\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Logistic Distribution\n\nSamples from a Logistic distribution.\n\nThe Logistic distribution is a continuous probability distribution defined by two parameters: location and scale. It is often used to model growth processes and is closely related to the normal distribution.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   f(x) = \\frac{1}{s} \\exp\\left(-\\frac{(x - \\mu)}{s}\\right)\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *loc* (jnp.ndarray or float): The location parameter, specifying the median of the distribution. Defaults to 0.0.\n\n- *sample* (jnp.ndarray or float): The scale parameter, which determines the spread of the distribution. Must be positive. Defaults to 1.0.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Logistic distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the Logistic distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.logistic(loc=0.0, scale=1.0, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#logistic\n\n##### low_rank_multivariate_normal { #BI.Utils.np_dists.UnifiedDist.low_rank_multivariate_normal }\n\n```python\nUtils.np_dists.UnifiedDist.low_rank_multivariate_normal(\n    loc,\n    cov_factor,\n    cov_diag,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Low Rank Multivariate Normal Distribution\n\nRepresents a multivariate normal distribution with a low-rank covariance structure.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}        \n   p(x) = \\frac{1}{\\sqrt{(2\\pi)^K |\\Sigma|}}} \\exp\\left(-\\frac{1}{2} (x - \\mu)^T \\Sigma^{-1} (x - \\mu)\\right)\n\\end{align*}\n```    \n\n\n\n\n\n\nwhere:\n\n* :math:`x` is a vector of observations.\n* :math:`\\mu` is the mean vector.\n* :math:`\\Sigma` is the covariance matrix, represented in a low-rank form.\n\nParameters:\n- *loc* (jnp.ndarray): Mean vector.\n\n    cov_factor (jnp.ndarray): Matrix used to construct the covariance matrix.\n\n    cov_diag (jnp.ndarray): Diagonal elements of the covariance matrix.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    event_size = 100  # Our distribution has 100 dimensions\n    rank = 5   \n    m.dist.low_rank_multivariate_normal(\n    - *loc*=m.dist.normal(0,1, shape = (event_size,), sample=True)*2, \n        cov_factor=m.dist.normal(0,1, shape = (event_size, rank), sample=True),\n        cov_diag=jnp.exp(m.dist.normal(0,1, shape = (event_size,), sample=True)) * 0.1, sample=True\n    )\n\n#### Wrapper of:\nhttps://num.pyro.ai/en/stable/distributions.html#lowrankmultivariatenormal\n\n##### lower_truncated_power_law { #BI.Utils.np_dists.UnifiedDist.lower_truncated_power_law }\n\n```python\nUtils.np_dists.UnifiedDist.lower_truncated_power_law(\n    alpha,\n    low,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### LowerTruncatedPowerLaw\n\n  Lower truncated power law distribution with :math:`\\alpha` index.\n\n  The probability density function (PDF) is given by:\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      f(x; \\alpha, a) = (-\\alpha-1)a^{-\\alpha - 1}x^{-\\alpha},\n      \\qquad x \\geq a, \\qquad \\alpha < -1,\n  \\end{align*}\n  ```        \n\n\n\n\n\n  where :math:`a` is the lower bound.\n\n\n  #### Args:\n      alpha (jnp.ndarray): index of the power law distribution. Must be less than -1.\n      low (jnp.ndarray): lower bound of the distribution. Must be greater than 0.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro LowerTruncatedPowerLaw distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the LowerTruncatedPowerLaw distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.lower_truncated_power_law(alpha=-2.0, low=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#lowertruncatedpowerlaw\n\n##### matrix_normal { #BI.Utils.np_dists.UnifiedDist.matrix_normal }\n\n```python\nUtils.np_dists.UnifiedDist.matrix_normal(\n    loc,\n    scale_tril_row,\n    scale_tril_column,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Matrix Normal Distribution\n\n  Samples from a Matrix Normal distribution, which is a multivariate normal distribution over matrices.\n  The distribution is characterized by a location matrix and two lower triangular matrices that define the correlation structure.\n  The distribution is related to the multivariate normal distribution in the following way.\n  If :math:`X ~ MN(loc,U,V)` then :math:`vec(X) ~ MVN(vec(loc), kron(V,U) )`.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      p(x) = \\frac{1}{2\\pi^{p/2} |\\Sigma|^{1/2}} \\exp\\left(-\\frac{1}{2} (x - \\mu)^T \\Sigma^{-1} (x - \\mu)\\right)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *loc* (array_like): Location of the distribution.\n\n      scale_tril_row (array_like): Lower cholesky of rows correlation matrix.\n\n      scale_tril_column (array_like): Lower cholesky of columns correlation matrix.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro MatrixNormal distribution object (for model building).\n\n- When `sample=True`: A JAX array of samples drawn from the MatrixNormal distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      import jax.numpy as jnp\n      m = bi('cpu')            \n      n_rows, n_cols = 3, 4\n\n  - *loc* = jnp.zeros((n_rows, n_cols))\n      U_row_cov = jnp.array([[1.0, 0.5, 0.2],\n                             [0.5, 1.0, 0.3],\n                             [0.2, 0.3, 1.0]])\n      scale_tril_row = jnp.linalg.cholesky(U_row_cov)\n\n      V_col_cov = jnp.array([[2.0, -0.8, 0.1, 0.4],\n                             [-0.8, 2.0, 0.2, -0.2],\n                             [0.1, 0.2, 2.0, 0.0],\n                             [0.4, -0.2, 0.0, 2.0]])\n\n      # The argument passed to the distribution is its Cholesky factor\n      scale_tril_column = jnp.linalg.cholesky(V_col_cov)\n\n      m.dist.matrix_normal(\n          oc=loc, \n          scale_tril_row=scale_tril_row, \n          scale_tril_column=scale_tril_column, \n          sample=True\n      )\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#matrixnormal_lowercase\n\n##### mixture { #BI.Utils.np_dists.UnifiedDist.mixture }\n\n```python\nUtils.np_dists.UnifiedDist.mixture(\n    mixing_distribution,\n    component_distributions,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### A marginalized finite mixture of component distributions.\n\n  This distribution represents a mixture of component distributions, where the\n  mixing weights are determined by a Categorical distribution. The resulting\n  distribution can be either a MixtureGeneral (when component distributions\n  are a list) or a MixtureSameFamily (when component distributions are a single\n  distribution).\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     p(x) = \\sum_{i=1}^{K} w_i p_i(x)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      Distribution #### Args:\n          None\n\n      Sampling / Modeling #### Args:\n      - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n              (model building), this is used with `.expand(shape)` to set the\n              distribution's batch shape. When `sample=True` (direct sampling),\n              this is used as `sample_shape` to draw a raw JAX array of the\n              given shape.\n\n      - *event* (int): The number of batch dimensions to reinterpret as event\n              dimensions (used in model building).\n\n      - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n      - *create_obj* (bool): If True, returns the raw NumPyro distribution\n              object instead of creating a sample site. This is essential for\n              building complex distributions like `MixtureSameFamily`.\n\n      - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n      - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n      - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n      - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Mixture distribution object (for model\n          building).\n\n- When `sample=True`: A JAX array of samples drawn from the Mixture\n          distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced\n          use cases).\n\n  #### Example Usage:\n      from jax import random\n      import numpyro as pyro\n      m = pyro.distributions.Mixture(\n          pyro.distributions.Categorical(torch.ones(2)),\n          [pyro.distributions.Normal(0, 1), pyro.distributions.Normal(2, 1)]\n      )\n      samples = m.sample(sample_shape=(10,))\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#mixture\n\n##### mixture_general { #BI.Utils.np_dists.UnifiedDist.mixture_general }\n\n```python\nUtils.np_dists.UnifiedDist.mixture_general(\n    mixing_distribution,\n    component_distributions,\n    support=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Mixture General Distribution\n\nA finite mixture of component distributions from different families.\n\n:param mixing_distribution: A :class:`~numpyro.distributions.Categorical` specifying the weights for each mixture component. The size of this distribution specifies the number of components in the mixture.\n:param component_distributions: A list of `mixture_size` :class:`~numpyro.distributions.Distribution` objects.\n:param support: A :class:`~numpyro.distributions.constraints.Constraint` object specifying the support of the mixture distribution. If not provided, the support will be inferred from the component distributions.\n\nThe probability density function (PDF) of a MixtureGeneral distribution is given by:\n\n$$\np(x) = \\sum_{i=1}^{K} \\pi_i p_i(x)\n$$\n\nwhere:\n\n*   $K$ is the number of components in the mixture.\n*   $\\pi_i$ is the mixing weight for the $i$-th component, such that $\\sum_{i=1}^{K} \\pi_i = 1$.\n*   $p_i(x)$ is the probability density function of the $i$-th component distribution.\n\n**Parameters:**\n\n*   **mixing_distribution**:  A `Categorical` distribution representing the mixing weights.\n\n*   **component_distributions**: A list of distributions representing the components of the mixture.\n\n*   **sample (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n*   **seed (int, optional)**:  An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n*   **obs (jnp.ndarray, optional)**:  The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n*   **name (str, optional)**:  The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n**#### Returns:**\n\n*   **When `sample=False`**: A NumPyro MixtureGeneral distribution object (for model building).\n*   **When `sample=True`**: A JAX array of samples drawn from the MixtureGeneral distribution (for direct sampling).\n*   **When `create_obj=True`**: The raw NumPyro distribution object (for advanced use cases).\n\n**#### Example Usage:**      \n\n    from BI import bi\n    m = bi('cpu')\n    m.dist.mixture_general(\n        mixing_distribution=m.dist.categorical(probs=jnp.array([0.3, 0.7]), create_obj = True),     \n        component_distributions=[m.dist.normal(loc=0.0, scale=1.0, create_obj=True),m.dist.normal  (loc=0.0, scale=1.0,  create_obj=True)],\n        sample = True\n    )           \n\n#### Wrapper of: [https://num.pyro.ai/en/stable/distributions.html#mixturegeneral](https://num.pyro.ai/en/stable/distributions.html#mixturegeneral)\n\n##### mixture_same_family { #BI.Utils.np_dists.UnifiedDist.mixture_same_family }\n\n```python\nUtils.np_dists.UnifiedDist.mixture_same_family(\n    mixing_distribution,\n    component_distribution,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n###  Finite mixture of component distributions from the same family.\n\nThis mixture only supports a mixture of component distributions that are all\nof the same family. The different components are specified along the last\nbatch dimension of the input ``component_distribution``. If you need a\nmixture of distributions from different families, use the more general\nimplementation in :class:`~numpyro.distributions.MixtureGeneral`.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   p(x) = \\sum_{k=1}^{K} w_k p_k(x)\n\\end{align*}\n```        \n\n\n\n\n\nwhere:\n\n*   $K$ is the number of mixture components.\n*   $w_k$ is the mixing weight for component $k$.\n*   $p_k(x)$ is the probability density function (PDF) of the $k$-th component distribution.\n\n\n#### Args:\n    *   **Distribution Args**:\n        *   **mixing_distribution**:  A `Categorical` distribution representing the mixing weights.\n\n        *   **component_distributions**: A list of distributions representing the components of the mixture.\n\n    *   **Sampling / Modeling Args**:\n        *   `shape` (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n            with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n            used as `sample_shape` to draw a raw JAX array of the given shape.\n\n        *   `event` (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n        *   `mask` (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n        *   `create_obj` (bool): If True, returns the raw NumPyro distribution object instead of creating a sample\n            site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n        *   **sample (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n        *   **seed (int, optional)**:  An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n        *   **obs (jnp.ndarray, optional)**:  The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n        *   **name (str, optional)**:  The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n\n#### Returns:\n    *   **When `sample=False`**: A NumPyro MixtureSameFamily distribution object (for model building).\n    *   **When `sample=True`**: A JAX array of samples drawn from the MixtureSameFamily distribution (for direct sampling).\n    *   **When `create_obj=True`**: The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.mixture_same_family(\n        mixing_distribution=m.dist.categorical(probs=jnp.array([0.3, 0.7]), create_obj = True), \n        component_distribution=m.dist.normal(loc=0.0, scale=1.0, shape = (2,), create_obj=True),\n        sample = True\n    )\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#mixture-same-family\n\n##### multinomial { #BI.Utils.np_dists.UnifiedDist.multinomial }\n\n```python\nUtils.np_dists.UnifiedDist.multinomial(\n    total_count=1,\n    probs=None,\n    logits=None,\n    total_count_max=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Multinomial distribution.\n\n  Samples from a Multinomial distribution, which models the probability of different outcomes in a sequence of independent trials, each with a fixed number of trials and a fixed set of possible outcomes.  It generalizes the binomial distribution to multiple categories.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     P(X = x) = \\frac{n!}{x_1! x_2! \\cdots x_k!} p_1^{x_1} p_2^{x_2} \\cdots p_k^{x_k}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      total_count (int or jnp.ndarray): The number of trials.\n\n  - *probs* (jnp.ndarray, optional): Event probabilities. Must sum to 1.\n\n      logits (jnp.ndarray, optional): Event log probabilities.\n\n      total_count_max (int, optional): An optional integer providing an upper bound on `total_count`. This is used for performance optimization with `lax.scan` when `total_count` is a dynamic JAX tracer, helping to avoid recompilation.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations.\n\n  - *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Multinomial distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Multinomial distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.multinomial(total_count=10, probs=jnp.array([0.2, 0.3, 0.5]), sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#multinomial\n\n##### multinomial_logits { #BI.Utils.np_dists.UnifiedDist.multinomial_logits }\n\n```python\nUtils.np_dists.UnifiedDist.multinomial_logits(\n    logits,\n    total_count=1,\n    total_count_max=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Multinomial Logits Distribution\n\n  Samples from a MultinomialLogits distribution.\n\n  This distribution represents the probability of observing a specific outcome from a multinomial experiment,\n  given the logits for each outcome. The logits are the natural logarithm of the odds of each outcome.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     P(k | \\mathbf{\\pi}) = \\frac{n!}{k! (n-k)!} \\prod_{i=1}^k \\pi_i\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      logits (jnp.ndarray): Logits for each outcome. Must be at least one-dimensional.\n\n      total_count (jnp.ndarray): The total number of trials.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro MultinomialLogits distribution object (for model building).\n\n- When `sample=True`: A JAX array of samples drawn from the MultinomialLogits distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.multinomial_logits(logits=jnp.array([1.0, 0.5], dtype=jnp.float32), total_count=jnp.array(5, dtype=jnp.int32), sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#multinomiallogits\n\n##### multinomial_probs { #BI.Utils.np_dists.UnifiedDist.multinomial_probs }\n\n```python\nUtils.np_dists.UnifiedDist.multinomial_probs(\n    probs,\n    total_count=1,\n    total_count_max=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Multinomial Probs Distribution\n\nSamples from a Multinomial distribution.\n\nThe Multinomial distribution models the number of times each of several discrete outcomes occurs in a fixed number of trials.  Each trial independently results in one of several outcomes, and each outcome has a probability of occurring.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   P(X = x) = \\frac{n!}{x_1! x_2! \\cdots x_k!} p_1^{x_1} p_2^{x_2} \\cdots p_k^{x_k}\n\\end{align*}\n```\n\n\n\n\n\n\nwhere:\n\n*   n is the total number of trials.\n*   x is a vector of counts for each outcome.\n*   p is a vector of probabilities for each outcome.\n\\end{align*}\n```\n\n#### Args:\n- *probs* (jnp.ndarray): Vector of probabilities for each outcome. Must sum to 1.\n    total_count (jnp.ndarray): The number of trials.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n        \n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n    \n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n    \n#### Returns:\n    NumPyro MultinomialProbs distribution object (for model building).\n    JAX array of samples drawn from the MultinomialProbs distribution (for direct sampling).\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.multinomial_probs(probs=jnp.array([0.2, 0.3, 0.5]), total_count=10, sample=True)\n\n#### Wrapper of:\nhttps://num.pyro.ai/en/stable/distributions.html#multinomialprobs\n\n##### multivariate_normal { #BI.Utils.np_dists.UnifiedDist.multivariate_normal }\n\n```python\nUtils.np_dists.UnifiedDist.multivariate_normal(\n    loc=0.0,\n    covariance_matrix=None,\n    precision_matrix=None,\n    scale_tril=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Multivariate Normal distribution.\n\n  The Multivariate Normal distribution, also known as the Gaussian distribution in multiple dimensions,\n  is a probability distribution that arises frequently in statistics and machine learning. It is\n  defined by its mean vector and covariance matrix, which describe the central tendency and\n  spread of the distribution, respectively.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      p(x) = \\frac{1}{\\sqrt{(2\\pi)^n |\\Sigma|}} \\exp\\left(-\\frac{1}{2}(x - \\mu)^T \\Sigma^{-1} (x - \\mu)\\right)\n  \\end{align*}\n  ```     \n\n\n\n\n\n\n  where:\n  - :math:`x` is a :math:`n`-dimensional vector of random variables.\n  - :math:`\\mu` is the mean vector.\n  - :math:`\\Sigma` is the covariance matrix.\n\n\n  #### Args:\n  - *loc* (tuple): The mean vector of the distribution.\n\n      covariance_matrix (jnp.ndarray, optional): The covariance matrix of the distribution. Must be positive definite.\n\n      precision_matrix (jnp.ndarray, optional): The precision matrix (inverse of the covariance matrix) of the distribution. Must be positive definite.\n\n      scale_tril (jnp.ndarray, optional): The lower triangular Cholesky decomposition of the covariance matrix.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro MultivariateNormal distribution object (for model building).\n\n- When `sample=True`: A JAX array of samples drawn from the MultivariateNormal distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n\n  from BI import bi\n  m = bi('cpu')\n  m.dist.multivariate_normal(\n  - *loc*=jnp.array([1.0, 0.0, -2.0]), \n      covariance_matrix=jnp.array([[ 2.0,  0.7, -0.3],\n                                  [ 0.7,  1.0,  0.5],\n                                  [-0.3,  0.5,  1.5]]), \n      sample=True\n  )\n\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#multivariate-normal\n\n##### multivariate_student_t { #BI.Utils.np_dists.UnifiedDist.multivariate_student_t }\n\n```python\nUtils.np_dists.UnifiedDist.multivariate_student_t(\n    df,\n    loc=0.0,\n    scale_tril=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Multivariate Student's t Distribution\n\n  The Multivariate Student's t distribution is a generalization of the Student's t\n  distribution to multiple dimensions. It is a heavy-tailed distribution that is\n  often used to model data that is not normally distributed.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      p(x) = \\frac{1}{B(df/2, n/2)} \\frac{\\Gamma(df/2 + n/2)}{\\Gamma(df/2)}\n      \\left(1 + \\frac{(x - \\mu)^T \\Sigma^{-1} (x - \\mu)}{df}\\right)^{-(df + n)/2}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      df (jnp.ndarray): Degrees of freedom, must be positive.\n  - *loc* (jnp.ndarray): Location vector, representing the mean of the distribution.\n      scale_tril (jnp.ndarray): Lower triangular matrix defining the scale.\n\n  Distribution #### Args:\n      df (jnp.ndarray): Degrees of freedom, must be positive.\n  - *loc* (jnp.ndarray): Location vector, representing the mean of the distribution.\n      scale_tril (jnp.ndarray): Lower triangular matrix defining the scale.\n\n  Sampling / Modeling #### Args:\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro MultivariateStudentT distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the MultivariateStudentT distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      import jax.numpy as jnp\n      m = bi('cpu')\n      m.dist.multivariate_student_t(\n          df = 2,\n      - *loc*=jnp.array([1.0, 0.0, -2.0]), \n          scale_tril=jnp.linalg.cholesky(\n              jnp.array([[ 2.0,  0.7, -0.3],\n                          [ 0.7,  1.0,  0.5],\n                          [-0.3,  0.5,  1.5]])), \n          sample=True\n      )   \n\n\n  #### Wrapper of:\n  https://num.pyro.ai/en/stable/distributions.html#multivariatestudentt\n\n##### negative_binomial { #BI.Utils.np_dists.UnifiedDist.negative_binomial }\n\n```python\nUtils.np_dists.UnifiedDist.negative_binomial(\n    total_count,\n    probs=None,\n    logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### NegativeBinomial distribution.\n\nThe NegativeBinomial distribution models the number of failures before the first success in a sequence of independent Bernoulli trials. It is characterized by two parameters: 'total_count' (r) and 'probs' or 'logits' (p).\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\nP(k) = \\binom{k+r-1}{r-1} p^r (1-p)^k\n\\end{align*}\n```\n\n\n\n\n\n\n\n#### Args:\n    total_count (jnp.ndarray): The total number of events.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro NegativeBinomial distribution object (for model building).\n    JAX array of samples drawn from the NegativeBinomial distribution (for direct sampling).\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.negative_binomial(total_count=5.0,probs = jnp.array([0.2, 0.3, 0.5]), sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#negativebinomial\n\n##### negative_binomial_logits { #BI.Utils.np_dists.UnifiedDist.negative_binomial_logits }\n\n```python\nUtils.np_dists.UnifiedDist.negative_binomial_logits(\n    total_count,\n    logits,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### NegativeBinomialLogits\n\nSamples from a NegativeBinomialLogits distribution.\n\nThe NegativeBinomialLogits distribution is a generalization of the Negative Binomial distribution where the parameter 'r' (number of successes) is expressed as a function of a logit parameter. This allows for more flexible modeling of count data.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\nP(k) = \\frac{e^{-n \\cdot \\text{softplus}(x)} \\cdot \\text{softplus}(-x)^k}{k!}\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    total_count (jnp.ndarray): The parameter controlling the shape of the distribution.  Represents the total number of trials.\n\n    logits (jnp.ndarray): The log-odds parameter.  Related to the probability of success.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NegativeBinomialLogits: A NumPyro NegativeBinomialLogits distribution object (for model building).\n\n    jnp.ndarray: A JAX array of samples drawn from the NegativeBinomialLogits distribution (for direct sampling).\n\n    NegativeBinomialLogits: The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.negative_binomial_logits(total_count=5.0, logits=0.0, sample=True)\n\n#### Wrapper of:\nhttps://num.pyro.ai/en/stable/distributions.html#negativebinomiallogits\n\n##### negative_binomial_probs { #BI.Utils.np_dists.UnifiedDist.negative_binomial_probs }\n\n```python\nUtils.np_dists.UnifiedDist.negative_binomial_probs(\n    total_count,\n    probs,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### NegativeBinomial distribution with probabilities.\n\nThe NegativeBinomial distribution models the number of failures before the first success in a sequence of independent Bernoulli trials.  It is characterized by two parameters: 'concentration' (r) and 'rate' (p).  In this implementation, the 'concentration' parameter is derived from 'total_count' and the 'rate' parameter is derived from 'probs'.\n\n\n\n\n\n\n```{latex}\nBegin{align*}\n    P(k) = \\binom{k+r-1}{r-1} p^r (1-p)^k\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    total_count (jnp.ndarray):  A numeric vector, matrix, or array representing the parameter.\n\n- *probs* (jnp.ndarray): A numeric vector representing event probabilities. Must sum to 1.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`  (model building), this is used   with `.expand(shape)` to set the distribution's     batch shape. When `sample=True` (direct sampling), this is    used as `sample_shape`    to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions    (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample  site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro NegativeBinomialProbs distribution object (for model building).\n    JAX array of samples drawn from the NegativeBinomialProbs distribution (for direct sampling).\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.negative_binomial_probs(total_count=10.0, probs = jnp.array([0.2, 0.3, 0.5]), sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#negativebinomialprobs\n\n##### normal { #BI.Utils.np_dists.UnifiedDist.normal }\n\n```python\nUtils.np_dists.UnifiedDist.normal(\n    loc=0.0,\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Normal Distribution\n\n  Samples from a Normal (Gaussian) distribution.\n\n  The Normal distribution is characterized by its mean (loc) and standard deviation (scale).\n  It's a continuous probability distribution that arises frequently in statistics and\n  probability theory.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     p(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *loc* (jnp.ndarray): The mean of the distribution.\n\n  - *sample* (jnp.ndarray): The standard deviation of the distribution.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n          JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Normal distribution object (for model building).\n\n- When `sample=True`: A JAX array of samples drawn from the Normal distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.normal(loc=0.0, scale=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#normal\n\n##### ordered_logistic { #BI.Utils.np_dists.UnifiedDist.ordered_logistic }\n\n```python\nUtils.np_dists.UnifiedDist.ordered_logistic(\n    predictor,\n    cutpoints,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### OrderedLogistic\n\n  A categorical distribution with ordered outcomes. This distribution represents the probability of an event falling into one of several ordered categories, based on a predictor variable and a set of cutpoints. The probability of an event falling into a particular category is determined by the number of categories above it.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     P(Y = k) = \\begin{cases}\n          1 & \\text{if } k = 0 \\\\\n          \\frac{1}{k} & \\text{if } k > 0\n      \\end{cases}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      predictor (jnp.ndarray): Prediction in real domain; typically this is output of a linear model.\n\n  Distribution #### Args:\n      cutpoints (jnp.ndarray): Positions in real domain to separate categories.\n\n  Sampling / Modeling #### Args:\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro OrderedLogistic distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the OrderedLogistic distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.ordered_logistic(predictor=jnp.array([0.2, 0.5, 0.8]), cutpoints=jnp.array([-1.0, 0.0, 1.0]), sample=True)\n\n  #### Wrapper of:\n  https://num.pyro.ai/en/stable/distributions.html#orderedlogistic\n\n##### pareto { #BI.Utils.np_dists.UnifiedDist.pareto }\n\n```python\nUtils.np_dists.UnifiedDist.pareto(\n    scale,\n    alpha,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Pareto Distribution\n\n  Samples from a Pareto distribution.\n\n  The Pareto distribution is a power-law probability distribution that is often\n  used to model income, wealth, and the size of cities. It is defined by two\n  parameters: alpha (shape) and scale.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      f(x) = \\frac{\\alpha \\cdot \\text{scale}^{\\alpha}}{x^{\\alpha + 1}}\n      \\text{ for } x \\geq \\text{scale}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *sample* (jnp.ndarray or float): Scale parameter of the Pareto distribution.\n          Must be positive.\n\n      alpha (jnp.ndarray or float): Shape parameter of the Pareto distribution.\n          Must be positive.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the\n          distribution's batch shape. When `sample=True` (direct sampling), this\n          is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event\n          dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object\n          instead of creating a sample site. This is essential for building\n          complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Pareto distribution object (for model\n          building).\n\n- When `sample=True`: A JAX array of samples drawn from the Pareto\n          distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced\n          use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.pareto(scale=2.0, alpha=3.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#pareto\n\n##### poisson { #BI.Utils.np_dists.UnifiedDist.poisson }\n\n```python\nUtils.np_dists.UnifiedDist.poisson(\n    rate,\n    is_sparse=False,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Poisson Distribution\n\n  Creates a Poisson distribution, a discrete probability distribution that models the number of events occurring in a fixed interval of time or space if these events occur with a known average rate and independently of the time since the last event.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n    \\mathrm{rate}^k \\frac{e^{-\\mathrm{rate}}}{k!}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      rate (jnp.ndarray): The rate parameter, representing the average number of events.\n      is_sparse (bool, optional): Indicates whether the `rate` parameter is sparse. If `True`, a specialized sparse sampling implementation is used, which can be more efficient for models with many zero-rate components (e.g., zero-inflated models). Defaults to `False`.\n  #### Args:\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n  - When `sample=False`: A NumPyro Poisson distribution object (for model building).\n  - When `sample=True`: A JAX array of samples drawn from the Poisson distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.poisson(rate=2.0, sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#poisson\n\n##### projected_normal { #BI.Utils.np_dists.UnifiedDist.projected_normal }\n\n```python\nUtils.np_dists.UnifiedDist.projected_normal(\n    concentration,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### ProjectedNormal distribution.\n\n  This distribution over directional data is qualitatively similar to the von\n  Mises and von Mises-Fisher distributions, but permits tractable variational\n  inference via reparametrized gradients.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     p(x) = \\frac{1}{Z} \\exp\\left(-\\frac{1}{2\\sigma^2} ||x - \\mu||^2\\right)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      concentration (jnp.ndarray): The concentration parameter, representing the\n          direction towards which the samples are concentrated.  Must be a\n          JAX array with at least one dimension.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the\n          distribution's batch shape. When `sample=True` (direct sampling),\n          this is used as `sample_shape` to draw a raw JAX array of the\n          given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event\n          dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object\n          instead of creating a sample site. This is essential for building\n          complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro ProjectedNormal distribution object (for\n          model building).\n\n- When `sample=True`: A JAX array of samples drawn from the\n          ProjectedNormal distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for\n          advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.projected_normal(concentration=jnp.array([1.0, 3.0, 2.0]), sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#projectednormal\n\n##### relaxed_bernoulli { #BI.Utils.np_dists.UnifiedDist.relaxed_bernoulli }\n\n```python\nUtils.np_dists.UnifiedDist.relaxed_bernoulli(\n    temperature,\n    probs=None,\n    logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Relaxed Bernoulli distribution.\n\nThe Relaxed Bernoulli distribution is a continuous relaxation of the discrete Bernoulli distribution.\nIt's useful for variational inference and other applications where a differentiable approximation of the Bernoulli is needed.\nThe probability density function (PDF) is defined as:\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    p(x) = \\frac{1}{2} \\left( 1 + \\tanh\\left(\\frac{x - \\beta \\log(\\frac{p}{1-p})}{1}\\right) \\right)\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    temperature (float): The temperature parameter.\n\n- *probs* (jnp.ndarray, optional): The probability of success. Must be in the interval `[0, 1]`. Only one of `probs` or `logits` can be specified.\n\n    logits (jnp.ndarray, optional): The log-odds of success. Only one of `probs` or `logits` can be specified.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n        with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n        used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n        This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro RelaxedBernoulli distribution object (for model building) when `sample=False`.\n    A JAX array of samples drawn from the RelaxedBernoulli distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.relaxed_bernoulli(temperature=1.0, probs = jnp.array([0.2, 0.3, 0.5]), sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#relaxedbernoulli\n\n##### relaxed_bernoulli_logits { #BI.Utils.np_dists.UnifiedDist.relaxed_bernoulli_logits }\n\n```python\nUtils.np_dists.UnifiedDist.relaxed_bernoulli_logits(\n    temperature,\n    logits,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Relaxed Bernoulli Logits Distribution.\n\nRepresents a relaxed version of the Bernoulli distribution, parameterized by logits and a temperature.\nThe temperature parameter controls the sharpness of the distribution.  The distribution is defined\nby transforming the output of a Logistic distribution through a sigmoid function.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    P(x) = \\sigma\\left(\\frac{x}{\\text{temperature}}\\right)\n\\end{align*}\n```\n\n\n\n\n\n#### Args:\n    temperature (jnp.ndarray): The temperature parameter, must be positive.\n    logits (jnp.ndarray): The logits parameter.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n        this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True`\n        (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample\n        site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    RelaxedBernoulliLogits: A NumPyro RelaxedBernoulliLogits distribution object (for model building).\n    jnp.ndarray: A JAX array of samples drawn from the RelaxedBernoulliLogits distribution (for direct sampling).\n    RelaxedBernoulliLogits: The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.relaxed_bernoulli_logits(temperature=1.0, logits=0.0, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#relaxed-bernoulli-logits\n\n##### right_truncated_distribution { #BI.Utils.np_dists.UnifiedDist.right_truncated_distribution }\n\n```python\nUtils.np_dists.UnifiedDist.right_truncated_distribution(\n    base_dist,\n    high=0.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### RightTruncatedDistribution\n\n  Samples from a right-truncated distribution.\n\n  This distribution truncates the base distribution at a specified high value.  Values greater than `high` are discarded,\n  effectively creating a distribution that is only supported up to that point. This is useful for modeling data\n  where observations are only possible within a certain range.\n\n  The probability density function (PDF) of the truncated distribution is:\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      f_{\\text{trunc}}(x) = \\frac{f_{\\text{base}}(x)}{F_{\\text{base}}(\\text{high})} \\quad \\text{for } x \\le \\text{high}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  where :math:`f_{\\text{base}}(x)` is the PDF of the base distribution and\n  :math:`F_{\\text{base}}(\\text{high})` is the cumulative distribution function (CDF)\n  of the base distribution evaluated at `high`.\n\n\n  where :math:`f(x)` is the probability density function (PDF) of the base distribution and :math:`P(X \\le high)` is the\n  cumulative distribution function (CDF) of the base distribution evaluated at `high`.\n  \\end{align*}\n  ```\n  \n  #### Args:\n      base_dist: The base distribution to truncate.  Must be a univariate distribution with real support.\n  \n      high (float, jnp.ndarray, optional): The upper truncation point. The support of the new distribution is :math:`(-\\infty, \\text{high}]`. Defaults to 0.0.\n      \n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n  \n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n  \n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n  \n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n          \n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n      \n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n      \n  #### Returns:\n- When `sample=False`: A NumPyro RightTruncatedDistribution distribution object (for model building).\n  \n- When `sample=True`: A JAX array of samples drawn from the RightTruncatedDistribution distribution (for direct sampling).\n  \n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n  \n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.right_truncated_distribution(base_dist = m.dist.normal(0,1, create_obj = True), high=0, sample=True)\n  \n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#righttruncateddistribution\n\n##### sine_bivariate_vonmises { #BI.Utils.np_dists.UnifiedDist.sine_bivariate_vonmises }\n\n```python\nUtils.np_dists.UnifiedDist.sine_bivariate_vonmises(\n    phi_loc,\n    psi_loc,\n    phi_concentration,\n    psi_concentration,\n    correlation=None,\n    weighted_correlation=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Sine Bivariate Von Mises Distribution\n\nA unimodal distribution for two dependent angles on the 2-torus\n(:math:`S^1 \\otimes S^1`), which is useful for modeling coupled angles like\ntorsion angles in peptide chains. [1]\n\nThe probability density function is given by:\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    C^{-1}\\exp(\\kappa_1\\cos(x_1-\\mu_1) + \\kappa_2\\cos(x_2 -\\mu_2) + \\rho\\sin(x_1 - \\mu_1)\\sin(x_2 - \\mu_2))\n\\end{align*}\n```\n\n\n\n\n\n\nwhere the normalization constant :math:`C` is:\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    C = (2\\pi)^2 \\sum_{i=0}^{\\infty} \\binom{2i}{i} \\left(\\frac{\\rho^2}{4\\kappa_1\\kappa_2}\\right)^i I_i(\\kappa_1)I_i(\\kappa_2)\n\\end{align*}\n```\n\n\n\n\n\n\nHere, :math:`I_i(\\cdot)` is the modified Bessel function of the first kind,\n:math:`\\mu`'s are the locations, :math:`\\kappa`'s are the concentrations,\nand :math:`\\rho` represents the correlation between the angles :math:`x_1` and :math:`x_2`.\n\n\n#### Args:\n    phi_loc (jnp.ndarray): The location parameter for the first angle (phi).\n    psi_loc (jnp.ndarray): The location parameter for the second angle (psi).\n    phi_concentration (jnp.ndarray): The concentration parameter for the first angle (phi). Must be positive.\n    psi_concentration (jnp.ndarray): The concentration parameter for the second angle (psi). Must be positive.\n    correlation (jnp.ndarray, optional): The correlation parameter between the two angles. One of `correlation` or `weighted_correlation` must be specified.\n    weighted_correlation (jnp.ndarray, optional): An alternative correlation parameter. One of `correlation` or `weighted_correlation` must be specified.\n    validate_args (bool, optional): Whether to enable validation of distribution parameters. Defaults to `None`.\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n- *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations. If provided, events with a `True` mask will be conditioned on `obs`, while the remaining events will be treated as latent variables. Defaults to `None`.\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution,   bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n- *shape* (tuple, optional): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to  set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n- *event* (int, optional): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n- *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for  building complex distributions like `MixtureSameFamily`. Defaults to `False`.\n\n#### Returns:\n    numpyro.primitives.Messenger: A NumPyro sample site object when used in a model context (`sample=False`).\n    jnp.ndarray: A JAX array of samples drawn from the SineBivariateVonMises distribution (for direct sampling, `sample=True`).\n    numpyro.distributions.Distribution: The raw NumPyro distribution object (if `create_obj=True`).\n\n#### Example Usage:\n    from BI import bi\n    import jax.numpy as jnp\n    m = bi('cpu')\n\n    # Direct sampling\n    samples = m.dist.sine_bivariate_vonmises(\n        phi_loc=0.0,\n        psi_loc=jnp.pi,\n        phi_concentration=1.0,\n        psi_concentration=1.0,\n        correlation=0.5,\n        sample=True,\n    - *shape*=(10,)\n    )\n\n    # Usage within a model\n    def my_model():\n        angles = m.dist.sine_bivariate_vonmises(\n            phi_loc=0.0,\n            psi_loc=0.0,\n            phi_concentration=2.0,\n            psi_concentration=2.0,\n            weighted_correlation=0.9,\n            name='angles'\n        )\n        # ... rest of the model\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#sinebivariatevonmises\n\n##### sine_skewed { #BI.Utils.np_dists.UnifiedDist.sine_skewed }\n\n```python\nUtils.np_dists.UnifiedDist.sine_skewed(\n    base_dist,\n    skewness,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Sine-skewing distribution\nSine-skewing [1] is a procedure for producing a distribution that breaks pointwise symmetry on a torus distribution. The new distribution is called the Sine Skewed X distribution, where X is the name of the (symmetric) base distribution. Torus distributions are distributions with support on products of circles (i.e., :math:`\\otimes S^1` where :math:`S^1 = [-pi,pi)`).\nSo, a 0-torus is a point, the 1-torus is a circle, and the 2-torus is commonly associated with the donut shape.\n\n.. note: This distribution is available in NumPyro: [https://num.pyro.ai/en/stable/distributions.html#sineskewed](https://num.pyro.ai/en/stable/distributions.html#sineskewed)\n\n**Parameters:**\n\n*   **base\\_dist:** Base density on a d-dimensional torus. Supported base distributions include: 1D :class:`~numpyro.distributions.VonMises`, :class:`~numnumpyro.distributions.SineBivariateVonMises`, 1D :class:`~numpyro.distributions.ProjectedNormal`, and :class:`~numpyro.distributions.Uniform` (-pi, pi).\n*   **skewness:** Skewness of the distribution.\n\n*   **sample (bool, optional):** A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n*   **seed (int, optional):** An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n*   **obs (jnp.ndarray, optional):** The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n*   **name (str, optional):** The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n**PDF:**\n\nThe probability density function (PDF) of the Sine Skewed X distribution is not explicitly defined here, but it is derived from the base distribution and the skewness parameter.\n\n**#### Example Usage:**\n\n\nfrom num.pyro import distributions as dist\nimport num.pyro as pyro\nimport num.numpy as np\n\nm = pyro.distributions.Normal(loc=0.0, scale=1.0)\nskewness = np.array([0.5, 0.5])\nsine_skewed = dist.SineSkewed(base_dist=m, skewness=skewness)\nsamples = sine_skewed.sample((1000,))\n\n##### soft_laplace { #BI.Utils.np_dists.UnifiedDist.soft_laplace }\n\n```python\nUtils.np_dists.UnifiedDist.soft_laplace(\n    loc,\n    scale,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### SoftLaplace\n\n  Samples from a SoftLaplace distribution.\n\n  This distribution is a smooth approximation of a Laplace distribution,\n  characterized by its log-convex density. It offers Laplace-like tails\n  while being infinitely differentiable, making it suitable for HMC and\n  Laplace approximation.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      f(x) = \\log(2 / \\pi) - \\log(scale) - \\logaddexp((x - loc) / scale, -(x - loc) / scale)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *loc*: Location parameter.\n      scale: Scale parameter.\n  \\end{align*}\n  ```\n  \n  #### Args:\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the\n          distribution's batch shape. When `sample=True` (direct sampling),\n          this is used as `sample_shape` to draw a raw JAX array of the\n          given shape.\n  \n  - *event* (int): The number of batch dimensions to reinterpret as event\n          dimensions (used in model building).\n  \n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n  \n  - *create_obj* (bool): If True, returns the raw NumPyro distribution\n          object instead of creating a sample site. This is essential for\n          building complex distributions like `MixtureSameFamily`.\n          \n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n      \n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n      \n  #### Returns:\n- When `sample=False`: A NumPyro SoftLaplace distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the SoftLaplace distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n  \n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.soft_laplace(loc=0.0, scale=1.0, sample=True)\n  \n  #### Wrapper of:\n  https://num.pyro.ai/en/stable/distributions.html#softlaplace\n\n##### student_t { #BI.Utils.np_dists.UnifiedDist.student_t }\n\n```python\nUtils.np_dists.UnifiedDist.student_t(\n    df,\n    loc=0.0,\n    scale=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Student's t-distribution.\n\n  The Student's t-distribution is a probability distribution that arises in hypothesis testing involving the mean of a normally distributed population when the population standard deviation is unknown. It is similar to the normal distribution, but has heavier tails, making it more robust to outliers.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      f(x) = \\frac{1}{\\Gamma(\\nu/2) \\sqrt{\\nu \\pi}} \\left(1 + \\frac{x^2}{\\nu}\\right)^{-(\\nu+1)/2}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      df (jnp.ndarray): Degrees of freedom, must be positive.\n  - *loc* (jnp.ndarray): Location parameter, defaults to 0.0.\n  - *sample* (jnp.ndarray): Scale parameter, defaults to 1.0.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`  (model building), this is used   with `.expand(shape)` to set the distribution's     batch shape. When `sample=True` (direct sampling), this is    used as `sample_shape`    to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions    (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro StudentT distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the StudentT distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.student_t(df = 2, loc=0.0, scale=1.0, sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#studentt\n\n##### truncated_cauchy { #BI.Utils.np_dists.UnifiedDist.truncated_cauchy }\n\n```python\nUtils.np_dists.UnifiedDist.truncated_cauchy(\n    loc=0.0,\n    scale=1.0,\n    low=None,\n    high=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Truncated Cauchy distribution.\n\nThe Cauchy distribution, also known as the Lorentz distribution, is a continuous probability distribution\nthat appears frequently in various areas of mathematics and physics. It is characterized by its heavy tails,\nwhich extend to infinity. The truncated version limits the support of the Cauchy distribution to a specified interval.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x) = \\frac{1}{\\pi \\cdot c \\cdot (1 + ((x - b) / c)^2)}  \\text{ for } a < x < b\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *loc* (float): Location parameter of the Cauchy distribution.\n\n- *sample* (float): Scale parameter of the Cauchy distribution.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n        this is used with `.expand(shape)` to set the distribution's batch shape.\n        When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n        This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro TruncatedCauchy distribution object (for model building) when `sample=False`.\n\n    JAX array of samples drawn from the TruncatedCauchy distribution (for direct sampling) when `sample=True`.\n\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.truncated_cauchy(loc=0.0, scale=1.0, sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#truncatedcauchy\n\n##### truncated_distribution { #BI.Utils.np_dists.UnifiedDist.truncated_distribution }\n\n```python\nUtils.np_dists.UnifiedDist.truncated_distribution(\n    base_dist,\n    low=None,\n    high=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### TruncatedDistribution\n\n  Samples from a Truncated Distribution.\n\n  This distribution represents a base distribution truncated between specified lower and upper bounds.\n  The truncation modifies the probability density function (PDF) of the base distribution,\n  effectively removing observations outside the defined interval.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     p(x) = \\frac{p(x)}{P(\\text{lower} \\le x \\le \\text{upper})}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      base_dist: The base distribution to be truncated. This should be a univariate\n          distribution. Currently, only the following distributions are supported:\n          Cauchy, Laplace, Logistic, Normal, and StudentT.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n          (model building), this is used with `.expand(shape)` to set the distribution's\n          batch shape. When `sample=True` (direct sampling), this is used as `sample_shape`\n          to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions\n          (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of\n          creating a sample site. This is essential for building complex distributions\n          like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro TruncatedDistribution distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the TruncatedDistribution distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.truncated_distribution(base_dist = m.dist.normal(0,1, create_obj = True), high=1, low = 0, sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#truncateddistribution\n\n##### truncated_normal { #BI.Utils.np_dists.UnifiedDist.truncated_normal }\n\n```python\nUtils.np_dists.UnifiedDist.truncated_normal(\n    loc=0.0,\n    scale=1.0,\n    low=None,\n    high=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Truncated Normal distribution.\n\nThe Truncated Normal distribution is a normal distribution truncated\nto a specified interval. It is defined by its location (`loc`), scale\n(`scale`), lower bound (`low`), and upper bound (`high`).\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   f(x) = \\frac{p(x)}{\\alpha}\n   \\text{ where }\n   p(x) \\text{ is the PDF of the Normal distribution with location } \\loc \\text{ and scale } \\scale,\n   \\alpha = \\int_{low}^{high} p(x) dx\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n- *loc* (float): The location parameter of the normal distribution.\n- *sample* (float): The scale parameter of the normal distribution.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n        (model building), this is used with `.expand(shape)` to set the\n        distribution's batch shape. When `sample=True` (direct sampling),\n        this is used as `sample_shape` to draw a raw JAX array of the\n        given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event\n        dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution\n        object instead of creating a sample site. This is essential for\n        building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro TruncatedNormal distribution object (for model building).\n    JAX array of samples drawn from the TruncatedNormal distribution (for\n    direct sampling).\n    The raw NumPyro distribution object (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.truncated_normal(loc=0.0, scale=1.0, sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#truncatednormal_lowercase\n\n##### truncated_polya_gamma { #BI.Utils.np_dists.UnifiedDist.truncated_polya_gamma }\n\n```python\nUtils.np_dists.UnifiedDist.truncated_polya_gamma(\n    batch_shape=(),\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### TruncatedPolyaGamma Distribution\n\n  Samples from a TruncatedPolyaGamma distribution.\n\n  This distribution is a truncated version of the PolyaGamma distribution,\n  defined over the interval [0, truncation_point]. It is often used in\n  Bayesian non-parametric models.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     p(x) = \\frac{1}{Z} \\exp\\left( \\sum_{n=0}^{N} \\left( \\log(2n+1) - 1.5 \\log(x) - \\frac{(2n+1)^2}{4x} \\right) \\right)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      batch_shape (tuple): The shape of the batch dimension.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions.\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro TruncatedPolyaGamma distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the TruncatedPolyaGamma distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.truncated_polya_gamma(batch_shape=(), sample=True)\n\n  #### Wrapper of:\n  https://num.pyro.ai/en/stable/distributions.html#truncatedpolygammadistribution\n\n##### two_sided_truncated_distribution { #BI.Utils.np_dists.UnifiedDist.two_sided_truncated_distribution }\n\n```python\nUtils.np_dists.UnifiedDist.two_sided_truncated_distribution(\n    base_dist,\n    low=0.0,\n    high=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### TwoSided Truncated Distribution\n\n  This distribution truncates a base distribution between two specified lower and upper bounds.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      f(x) = \\begin{cases}\n          \\frac{p(x)}{P(\\text{low} \\le X \\le \\text{high})} & \\text{if } \\text{low} \\le x \\le \\text{high} \\\\\n          0 & \\text{otherwise}\n      \\end{cases}\n  \n  where :math:`p(x)` is the probability density function of the base distribution.\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      base_dist: The base distribution to truncate.\n\n      low: The lower bound for truncation.\n\n      high: The upper bound for truncation.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro TwoSidedTruncatedDistribution distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the TwoSidedTruncatedDistribution distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#twosidedtruncateddistribution\n\n##### uniform { #BI.Utils.np_dists.UnifiedDist.uniform }\n\n```python\nUtils.np_dists.UnifiedDist.uniform(\n    low=0.0,\n    high=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Uniform Distribution\n\nSamples from a Uniform distribution, which is a continuous probability distribution\nwhere all values within a given interval are equally likely.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n   f(x) = \\frac{1}{b - a}, \\text{ for } a \\le x \\le b\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    low (jnp.ndarray): The lower bound of the uniform interval.\n\n    high (jnp.ndarray): The upper bound of the uniform interval.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`\n        (model building), this is used with `.expand(shape)` to set the\n        distribution's batch shape. When `sample=True` (direct sampling), this\n        is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions\n        (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object\n        instead of creating a sample site. This is essential for building\n        complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Uniform distribution object (for model building) when `sample=False`.\n\n    JAX array of samples drawn from the Uniform distribution (for direct\n    sampling) when `sample=True`.\n\n    The raw NumPyro distribution object (for advanced use cases) when\n    `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.uniform(low=0.0, high=1.0, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#uniform\n\n##### unit { #BI.Utils.np_dists.UnifiedDist.unit }\n\n```python\nUtils.np_dists.UnifiedDist.unit(\n    log_factor,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Unit Distribution\n\nThe Unit distribution is a trivial, non-normalized distribution representing the unit type.\nIt has a single value with no data, effectively a placeholder often used in probabilistic programming\nfor situations where no actual data is involved.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    p(x) = 1\n\\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    log_factor (jnp.ndarray): Log factor for the unit distribution. This parameter determines the\n    - *shape* and batch size of the distribution.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n        this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True`\n        (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample\n        site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Unit distribution object: When `sample=False` (for model building).\n    jnp.ndarray: A JAX array of samples drawn from the Unit distribution (for direct sampling).\n    NumPyro Unit distribution object: When `create_obj=True` (for advanced use cases).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.unit(log_factor=jnp.ones(5), sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#unit\n\n##### weibull { #BI.Utils.np_dists.UnifiedDist.weibull }\n\n```python\nUtils.np_dists.UnifiedDist.weibull(\n    scale,\n    concentration,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Weibull Distribution\n\nSamples from a Weibull distribution.\n\nThe Weibull distribution is a versatile distribution often used to model failure rates in engineering and reliability studies. It is characterized by its shape and scale parameters.\n\n\n\n\n\n\n```{latex}\n\\begin{align*}\n    f(x) = \\frac{\\beta}{\\alpha} \\left(\\frac{x}{\\alpha}\\right)^{\\beta - 1} e^{-\\left(\\frac{x}{\\alpha}\\right)^{\\beta}} \\text{ for } x \\ge 0\n\\end{align*}\n```        \n\n\n\n\n\nwhere :math:`\\alpha` is the scale parameter and :math:`\\beta` is the shape parameter.\n\n\n#### Args:\n- *sample* (jnp.ndarray): The scale parameter of the Weibull distribution. Must be positive.\n    concentration (jnp.ndarray): The shape parameter of the Weibull distribution. Must be positive.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used\n        with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n        used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n        This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro Weibull distribution object (for model building) when `sample=False`.\n    JAX array of samples drawn from the Weibull distribution (for direct sampling) when `sample=True`.\n    The raw NumPyro distribution object (for advanced use cases) when `create_obj=True`.\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.weibull(scale=1.0, concentration=2.0, sample=True)\n\n#### Wrapper of:\n    https://num.pyro.ai/en/stable/distributions.html#weibull\n\n##### wishart { #BI.Utils.np_dists.UnifiedDist.wishart }\n\n```python\nUtils.np_dists.UnifiedDist.wishart(\n    concentration,\n    scale_matrix=None,\n    rate_matrix=None,\n    scale_tril=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Wishart Distribution\n\n  The Wishart distribution is a multivariate distribution used to model positive definite matrices,\n  often representing covariance matrices. It's commonly used in Bayesian statistics and machine learning,\n  particularly in models involving covariance estimation.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n     p(X) = \\frac{1}{W^{p/2} \\Gamma_p(concentration/2)} \\left|X\\right|^{-concentration/2} \\exp\\left(-\\frac{1}{2} \\text{tr}(X^{-1} X)\\right)\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      concentration (jnp.ndarray): Positive concentration parameter analogous to the\n          concentration of a :class:`Gamma` distribution. The concentration must be larger\n          than the dimensionality of the scale matrix.\n\n      scale_matrix (jnp.ndarray, optional): Scale matrix analogous to the inverse rate of a :class:`Gamma`\n          distribution.\n\n      rate_matrix (jnp.ndarray, optional): Rate matrix anaologous to the rate of a :class:`Gamma`\n          distribution.\n\n      scale_tril (jnp.ndarray, optional): Cholesky decomposition of the :code:`scale_matrix`.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False`  (model building), this is used\n          with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is\n          used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions    (used in model building).\n\n  - *mask* (jnp.ndarray, bool, optional): Optional boolean array to mask observations.\n\n  - *create_obj* (bool, optional): If True, returns the raw NumPyro distribution object instead of creating a sample\n          site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro Wishart distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the Wishart distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.wishart(concentration=5.0, scale_matrix=jnp.eye(2), sample=True)\n\n  #### Wrapper of:\n      https://num.pyro.ai/en/stable/distributions.html#wishart\n\n##### wishart_cholesky { #BI.Utils.np_dists.UnifiedDist.wishart_cholesky }\n\n```python\nUtils.np_dists.UnifiedDist.wishart_cholesky(\n    concentration,\n    scale_matrix=None,\n    rate_matrix=None,\n    scale_tril=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### WishartCholesky Distribution\n\nThe Wishart distribution is a multivariate distribution used as a prior distribution\nfor covariance matrices. This implementation represents the distribution in terms\nof its Cholesky decomposition.\n\n.. rubric:: Probability Density Function\n\nThe probability density function (PDF) is given by:\n\nPDF = (1 / ((2 * pi)^(k * (k - 1) / 2) * Gamma(k/2)) *\n       (concentration^(k/2) * det(scale_matrix))^(-1/2) *\n       exp(-1/2 * trace(rate_matrix @ scale_matrix)))\n\nwhere:\n\n- k is the dimensionality of the covariance matrix.\n- concentration is a positive concentration parameter.\n- scale_matrix is the scale matrix.\n- rate_matrix is the rate matrix.\n- Gamma is the gamma function.\n\n.. rubric:: Parameters\n\n:param concentration: (Tensor) Positive concentration parameter analogous to the\n    concentration of a :class:`Gamma` distribution. The concentration must be larger\n    than the dimensionality of the scale matrix.\n\n:param scale_matrix: (Tensor, optional) Scale matrix analogous to the inverse rate of a :class:`Gamma`\n        distribution. If not provided, `rate_matrix` or `scale_tril` must be.\n\n:param rate_matrix: (Tensor, optional) Rate matrix anaologous to the rate of a :class:`Gamma`\n        distribution. If not provided, `scale_matrix` or `scale_tril` must be.\n\n:param scale_tril: (Tensor, optional) Cholesky decomposition of the :code:`scale_matrix`.\n    If not provided, `scale_matrix` or `rate_matrix` must be.\n\n:param sample (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n:param seed (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n:param obs (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n:param name (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n##### zero_inflated_distribution { #BI.Utils.np_dists.UnifiedDist.zero_inflated_distribution }\n\n```python\nUtils.np_dists.UnifiedDist.zero_inflated_distribution(\n    base_dist,\n    gate=None,\n    gate_logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Generic Zero Inflated distribution.\n\n  A Zero-Inflated distribution combines a base distribution with a Bernoulli distribution\n  to model data with an excess of zero values. It assumes that each observation\n  is either drawn from the base distribution or is a zero with probability determined\n  by the Bernoulli distribution (the \"gate\"). This is useful for modeling data\n  where zeros are more frequent than expected under a single distribution,\n  often due to a different underlying process.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      P(x) = \\pi \\cdot I(x=0) + (1 - \\pi) \\cdot P_{base}(x)\n  \\end{align*}\n  ```\n\n\n\n\n\n  where:\n  - $P_{base}(x)$ is the probability density function (PDF) or probability mass function (PMF) of the base distribution.\n  - $\\pi$ is the probability of generating a zero, governed by the Bernoulli gate.\n  - $I(x=0)$ is an indicator function that equals 1 if x=0 and 0 otherwise.\n\n\n  #### Args:\n      base_dist (Distribution): The base distribution to be zero-inflated (e.g., Poisson,     NegativeBinomial).\n\n      gate (jnp.ndarray, optional): Probability of extra zeros (between 0 and 1).\n\n      gate_logits (jnp.ndarray, optional): Log-odds of extra zeros.\n\n      validate_args (bool, optional): Whether to validate parameter values. Defaults to None.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n          JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro ZeroInflatedDistribution distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the ZeroInflatedDistribution distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.zero_inflated_distribution(base_dist=m.dist.poisson(rate=5, create_obj = True), gate = 0.3, sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#zeroinflateddistribution\n\n##### zero_inflated_negative_binomial2 { #BI.Utils.np_dists.UnifiedDist.zero_inflated_negative_binomial2 }\n\n```python\nUtils.np_dists.UnifiedDist.zero_inflated_negative_binomial2(\n    mean,\n    concentration,\n    gate=None,\n    gate_logits=None,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Zero-Inflated Negative Binomial 2 distribution.\n\n  This distribution combines a Negative Binomial 2 distribution with a binary gate variable.\n  Observations are either drawn from the Negative Binomial 2 distribution with probability\n  (1 - gate) or are treated as zero with probability 'gate'. This models data with excess zeros\n  compared to what a standard Negative Binomial 2 distribution would predict.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      P(X = x) = (1 - gate) \\cdot \\frac{\\Gamma(x + \\alpha)}{\\Gamma(x + \\alpha + \\beta) \\Gamma(\\alpha)} \\left(\\frac{\\beta}{\\alpha + \\beta}\\right)^x + gate \\cdot \\delta_{x, 0}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n      mean (jnp.ndarray or float): The mean of the Negative Binomial 2 distribution.\n      concentration (jnp.ndarray or float): The concentration parameter of the Negative Binomial 2 distribution.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building),\n          this is used with `.expand(shape)` to set the distribution's batch shape.\n          When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw\n          JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site.\n          This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro ZeroInflatedNegativeBinomial2 distribution object (for model building).\n- When `sample=True`: A JAX array of samples drawn from the ZeroInflatedNegativeBinomial2 distribution (for direct sampling).\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.zero_inflated_negative_binomial2(mean=2.0, concentration=3.0, gate = 0.3, sample=True)\n\n  #### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#zeroinflatednegativebinomial2\n\n##### zero_inflated_poisson { #BI.Utils.np_dists.UnifiedDist.zero_inflated_poisson }\n\n```python\nUtils.np_dists.UnifiedDist.zero_inflated_poisson(\n    gate,\n    rate=1.0,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### A Zero Inflated Poisson distribution.\n\nThis distribution combines two Poisson processes: one with a rate parameter and another that generates only zeros.\nThe probability of observing a zero is determined by the 'gate' parameter, while the probability of observing a non-zero value is governed by the 'rate' parameter of the underlying Poisson distribution.\n\n\n\n\n\n\n```{latex}\n    \\begin{align*}\n    P(X = k) = (1 - gate) * \\frac{e^{-rate} rate^k}{k!} + gate\n    \\end{align*}\n```\n\n\n\n\n\n\n#### Args:\n    rate (jnp.ndarray): The rate parameter of the underlying Poisson distribution.\n\n- *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n- *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n- *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n- *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n- *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n- *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n- *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n- *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n#### Returns:\n    NumPyro ZeroInflatedPoisson distribution object (when `sample=False`).\n    JAX array of samples drawn from the ZeroInflatedPoisson distribution (when `sample=True`).\n    The raw NumPyro distribution object (when `create_obj=True`).\n\n#### Example Usage:\n    from BI import bi\n    m = bi('cpu')\n    m.dist.zero_inflated_poisson(gate = 0.3, rate=2.0, sample=True)\n\n#### Wrapper of: https://num.pyro.ai/en/stable/distributions.html#zeroinflatedpoisson\n\n##### zero_sum_normal { #BI.Utils.np_dists.UnifiedDist.zero_sum_normal }\n\n```python\nUtils.np_dists.UnifiedDist.zero_sum_normal(\n    scale,\n    event_shape,\n    validate_args=None,\n    name='x',\n    obs=None,\n    mask=None,\n    sample=False,\n    seed=0,\n    shape=(),\n    event=0,\n    create_obj=False,\n)\n```\n\n### Zero Sum Normal Distribution\n\n  Samples from a ZeroSumNormal distribution, which is a Normal distribution where one or more axes are constrained to sum to zero.\n\n\n\n\n\n\n  ```{latex}\n  \\begin{align*}\n      \\begin{align*}\n      ZSN(\\sigma) = N(0, \\sigma^2 (I - \\tfrac{1}{n}J)) \\\\\n      \\text{where} \\ ~ J_{ij} = 1 \\ ~ \\text{and} \\\\\n      n = \\text{number of zero-sum axes}\n      \\end{align*}\n  \\end{align*}\n  ```\n\n\n\n\n\n\n  #### Args:\n  - *sample* (array_like): Standard deviation of the underlying normal distribution before the zerosum constraint is enforced.\n\n  - *shape* (tuple): A multi-purpose argument for shaping. When `sample=False` (model building), this is used with `.expand(shape)` to set the distribution's batch shape. When `sample=True` (direct sampling), this is used as `sample_shape` to draw a raw JAX array of the given shape.\n\n  - *event* (int): The number of batch dimensions to reinterpret as event dimensions (used in model building).\n\n  - *mask* (jnp.ndarray, bool): Optional boolean array to mask observations.\n\n  - *create_obj* (bool): If True, returns the raw NumPyro distribution object instead of creating a sample site. This is essential for building complex distributions like `MixtureSameFamily`.\n\n  - *sample* (bool, optional): A control-flow argument. If `True`, the function will directly sample a raw JAX array from the distribution, bypassing the NumPyro model context. If `False`, it will create a `numpyro.sample` site within a model. Defaults to `False`.\n\n  - *seed* (int, optional): An integer used to generate a JAX PRNGKey for reproducible sampling when `sample=True`. [7] This argument has no effect when `sample=False`, as randomness is handled by NumPyro's inference engine. Defaults to 0.\n\n  - *obs* (jnp.ndarray, optional): The observed value for this random variable. If provided, the sample site is conditioned on this value, and the    function returns the observed value. If `None`, the site is treated as a latent (unobserved) random variable. Defaults to `None`.\n\n  - *name* (str, optional): The name of the sample site in a NumPyro model. This is used to uniquely identify the random variable. Defaults to 'x'.\n\n  #### Returns:\n- When `sample=False`: A NumPyro ZeroSumNormal distribution object (for model building).\n\n- When `sample=True`: A JAX array of samples drawn from the ZeroSumNormal distribution (for direct sampling).\n\n- When `create_obj=True`: The raw NumPyro distribution object (for advanced use cases).\n\n  #### Example Usage:\n      from BI import bi\n      m = bi('cpu')\n      m.dist.zero_sum_normal(scale=1.0, event_shape = (2,), sample = True)\n\n  #### Wrapper of:\n  https://num.pyro.ai/en/stable/distributions.html#zerosumnormal\n\n\n",
    "supporting": [
      "Utils.np_dists_files"
    ],
    "filters": [],
    "includes": {}
  }
}