{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Measurement Error Models\"\n",
        "description: \"Statistical models that explicitly account for errors in the measurement of predictor variables.\"\n",
        "categories: [Regression, Biases]\n",
        "image: \"Figures/16.png\"\n",
        "order: 19\n",
        "---\n",
        "\n",
        "## General Principles\n",
        "Measurement error refers to the variability in the measurement of a variable, and measurement error can be generated by several factors, such as sampling bias, censoring bias, and group size heterogeneity. It is an important consideration in many fields, including statistics, economics, and engineering, where accurate measurements are crucial for making informed decisions. To account for measurement error, we can use a _measurement error model_. This model assumes that the measurement of a variable is subject to an error, which can be modeled using a probability distribution. The model can be used to estimate the parameters of the measurement error distribution, such as the mean and variance, and to make predictions about the measurements based on the estimated parameters. Measurement error models are _composed models_ (i.e., models with sub-models) that evaluate different generative processes, starting with the measurement error process, which is then used to generate the observed data.\n",
        "\n",
        "\n",
        "## Example\n",
        "Below is an example code snippet demonstrating a Bayesian measurement error model using the Bayesian Inference (BI) package. The data consist of three continuous variables (marriage rate, divorce rate, age), and the goal is to estimate the effect of age and marriage rate on the divorce rate while considering that the divorce rate has a measurement error. This example is based on @mcelreath2018statistical.\n",
        "\n",
        "::: {.panel-tabset group=\"language\"}\n",
        "## Python"
      ],
      "id": "1baaca4f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from BI import bi, jnp\n",
        "\n",
        "# Setup device------------------------------------------------\n",
        "m = bi(platform='cpu')\n",
        "\n",
        "# Import Data & Data Manipulation ------------------------------------------------\n",
        "# Import\n",
        "data_path = m.load.WaffleDivorce(only_path=True)\n",
        "m.data(data_path, sep=';') \n",
        "m.scale(['MedianAgeMarriage', 'Marriage']) # Scale\n",
        "dat = dict(\n",
        "    D_obs = m.z_score(m.df['Divorce'].values),   \n",
        "    D_sd = jnp.array(m.df['Divorce SE'].values / m.df['Divorce'].std()), \n",
        "    A = jnp.array(m.df['MedianAgeMarriage'].values), \n",
        "    M = jnp.array(m.df['Marriage'].values),\n",
        "    N = m.df.shape[0]   \n",
        ")\n",
        "m.data_on_model = dat # Send to model (convert to jax array)\n",
        "\n",
        "# Define model ------------------------------------------------\n",
        "def model(D_obs, D_sd, A, N, M):  \n",
        "    a = m.dist.normal(0, 0.2, name = 'a') \n",
        "    beta = m.dist.normal(0, 0.5, name = 'beta')\n",
        "    eta = m.dist.normal(0, 0.5, name = 'eta')  \n",
        "    s = m.dist.exponential(1, name = 's') \n",
        "    mu = a + beta * A + eta * M\n",
        "    D_true = m.dist.normal(mu, s, name = 'D_true') \n",
        "    m.dist.normal(D_true , D_sd, obs = D_obs) \n",
        "\n",
        "# Run MCMC ------------------------------------------------\n",
        "m.fit(model)  # Optimize model parameters through MCMC sampling\n",
        "\n",
        "# Summary ------------------------------------------------\n",
        "m.summary() # Get posterior distributions"
      ],
      "id": "e020d6c7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## R\n",
        "``` R\n",
        "library(BayesianInference)\n",
        "jnp = reticulate::import('jax.numpy')\n",
        "\n",
        "# Setup platform------------------------------------------------\n",
        "m=importBI(platform='cpu')\n",
        "\n",
        "# Import data ------------------------------------------------\n",
        "m$data(paste(system.file(package = \"BayesianInference\"),\"/data/WaffleDivorce.csv\", sep = ''), sep=';')\n",
        "\n",
        "m$scale(list('MedianAgeMarriage', 'Marriage'))\n",
        "\n",
        "m$data_on_model$D_obs = m$z_score(jnp$array(m$df['Divorce']))\n",
        "m$data_on_model$D_sd = jnp$array(m$df['Divorce SE']) / sd(unlist(m$df['Divorce']))\n",
        "m$data_on_model$A = jnp$array(m$df['MedianAgeMarriage'])\n",
        "m$data_on_model$M = jnp$array(m$df['Marriage'])\n",
        "m$data_on_model$N = as.integer(nrow(m$df))\n",
        "\n",
        "# Define model ------------------------------------------------\n",
        "model <- function(D_obs, D_sd, A, N, M){\n",
        "  a = bi.dist.normal(0, 0.2, name = 'a') \n",
        "  beta = bi.dist.normal(0, 0.5, name = 'beta')\n",
        "  eta = bi.dist.normal(0, 0.5, name = 'eta') \n",
        "  s = bi.dist.exponential(1, name = 's') \n",
        "  mu = a + beta * A + eta * M\n",
        "  D_true = bi.dist.normal(mu, s, name = 'D_true') \n",
        "  bi.dist.normal(D_true , D_sd, obs = D_obs) \n",
        "}\n",
        "\n",
        "# Run MCMC ------------------------------------------------\n",
        "m$fit(model) # Optimize model parameters through MCMC sampling\n",
        "\n",
        "# Summary ------------------------------------------------\n",
        "m$summary() # Get posterior distribution\n",
        "\n",
        "```\n",
        "## Julia\n",
        "```julia\n",
        "using BayesianInference\n",
        "\n",
        "# Setup device------------------------------------------------\n",
        "m = importBI(platform=\"cpu\")\n",
        "\n",
        "# Import Data & Data Manipulation ------------------------------------------------\n",
        "# Import\n",
        "data_path = m.load.WaffleDivorce(only_path=true)\n",
        "m.data(data_path, sep=\";\") \n",
        "m.scale([\"MedianAgeMarriage\", \"Marriage\"]) # Scale\n",
        "dat = pydict(\n",
        "    D_obs = m.z_score(m.df[\"Divorce\"].values),   \n",
        "    D_sd = jnp.array(m.df[\"Divorce SE\"].values / m.df[\"Divorce\"].std()), \n",
        "    A = jnp.array(m.df[\"MedianAgeMarriage\"].values), \n",
        "    M = jnp.array(m.df[\"Marriage\"].values),\n",
        "    N = m.df.shape[0]   \n",
        ")\n",
        "m.data_on_model = dat # Send to model (convert to jax array)\n",
        "\n",
        "# Define model ------------------------------------------------\n",
        "@BI function model(D_obs, D_sd, A, N, M)\n",
        "    a = m.dist.normal(0, 0.2, name = \"a\") \n",
        "    beta = m.dist.normal(0, 0.5, name = \"beta\")\n",
        "    eta = m.dist.normal(0, 0.5, name = \"eta\")  \n",
        "    s = m.dist.exponential(1, name = \"s\") \n",
        "    mu = a + beta * A + eta * M\n",
        "    D_true = m.dist.normal(mu, s, name = \"D_true\") \n",
        "    m.dist.normal(D_true , D_sd, obs = D_obs) \n",
        "\n",
        "\n",
        "end\n",
        "\n",
        "# Run mcmc ------------------------------------------------\n",
        "m.fit(model)  # Optimize model parameters through MCMC sampling\n",
        "\n",
        "# Summary ------------------------------------------------\n",
        "m.summary() # Get posterior distributions\n",
        "```\n",
        "\n",
        ":::\n",
        "\n",
        "## Mathematical Details\n",
        "### *Bayesian formulation*\n",
        "\n",
        "$$\n",
        "D_i^* \\sim \\text{Normal}(D_i, \\varsigma_i)\n",
        "$$\n",
        "\n",
        "$$\n",
        "D_i \\sim \\text{Normal}(\\mu_i, \\sigma)\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\mu_i = \\alpha + \\beta A_i + \\eta M_i \n",
        "$$\n",
        "\n",
        "$$\n",
        "\\sigma \\sim \\text{Normal}(1)\n",
        "$$\n",
        "\n",
        "where:\n",
        "\n",
        "- $D_i^*$ is the observed divorce rate.\n",
        "\n",
        "- $D_i$ is the true divorce rate.\n",
        "\n",
        "- $\\mu_i$ is the mean of the true divorce rate.\n",
        "\n",
        "- $\\sigma$ is the standard deviation of the true divorce rate.\n",
        "\n",
        "- $\\alpha$ is the intercept term.\n",
        "\n",
        "- $\\beta$ is the regression coefficient for age.\n",
        "\n",
        "- $\\eta$ is the regression coefficient for marriage rate.    \n",
        "\n",
        "\n",
        "## Notes\n",
        "::: callout-note\n",
        "This is an approach that can be extended to any kind of model previously described. For example, one could generate a Bernoulli measurement error model by generating a process for the probabilities of success and failure. We can even go further by potentially having an error rate that is present only in one of the two outcomes.\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "## Reference(s)\n",
        "::: {#refs}\n",
        ":::"
      ],
      "id": "afaecc5a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/sosa/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}