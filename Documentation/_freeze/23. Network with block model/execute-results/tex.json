{
  "hash": "df133b7b5f19e23fe4a4c75b39fe5227",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Stochastic Block Models\"\ndescription: \"A generative model for random graphs used to find communities of nodes with similar connection patterns.\"\ncategories: [Network Analysis, Graph Theory, Community Detection]\nimage: \"Figures/23.png\"\norder: 26\n---\n\nWithin networks, nodes can belong to different categories, and these categories can potentially affect the propensity for node interactions. For example, nodes can have different sex categories, and the propensity to interact with nodes of the same sex can be higher than with nodes of different sexes. To model the propensity for interaction between nodes based on the categories they belong to, we can use a stochastic block model approach.\n\n## Considerations\n::: callout-caution\n- We consider predefined groups here, with the goal of evaluating the propensity for interaction between nodes within each group.\n- In addition to the block model(s) being tested, we need to include a block where all individuals are considered as belonging to the same group (```Any``` in the example). This allows us to assess whether interaction tendencies differ between groups or if the propensity to interact is uniform across all individuals.\n:::\n\n## Example\nBelow is an example code snippet demonstrating a Bayesian network model using the stochastic block model approach. The data is identical to the [Network model](20.&#32;Network&#32;model.qmd) example, with the addition of covariates *Any*, *Merica*, and *Quantum*, representing the block membership of each node. This example is based on @ross2024modelling.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# Setup device------------------------------------------------\nfrom BI import bi, jnp\n\n# Setup device------------------------------------------------\nm = bi(platform='cpu')\n# Simulate data ------------------------------------------------\nN = 50\nindividual_predictor = m.dist.normal(0,1, shape = (N,1), sample = True)\n\nkinship = m.dist.bernoulli(0.3, shape = (N,N), sample = True)\nkinship = kinship.at[jnp.diag_indices(N)].set(0)\n\ncategory = m.dist.categorical(jnp.array([.25,.25,.25,.25]), sample = True, shape  = (N,))\nN_grp, N_by_grp = jnp.unique(category, return_counts=True)\nN_grp = N_grp.shape[0]\n\ndef sim_network(kinship, individual_predictor,category):\n  # Intercept\n  B_intercept = m.net.block_model(jnp.full((N,),0), 1, N, sample = True)\n  B_category = m.net.block_model(category, N_grp, N_by_grp, sample = True)\n\n  # SR\n  sr = m.net.sender_receiver(\n    individual_predictor, \n    individual_predictor, \n    s_mu = 0.4, r_mu = -0.4, sample = True)\n\n  # D\n  DR = m.net.dyadic_effect(kinship, d_sd=2.5, sample = True)\n\n\n\n  return m.dist.bernoulli(\n    logits = B_intercept + B_category + sr + DR, \n    sample = True\n    )\n\n\nnetwork = sim_network(m.net.mat_to_edgl(kinship), individual_predictor, category)\n\n# Predictive model ------------------------------------------------\n\nm.data_on_model = dict(\n    network = network, \n    dyadic_predictors = m.net.mat_to_edgl(kinship),\n    focal_individual_predictors = individual_predictor,\n    target_individual_predictors = individual_predictor, \n    category = category\n)\n\n\ndef model(network, dyadic_predictors, focal_individual_predictors, target_individual_predictors,category):\n    N_id = focal_individual_predictors.shape[0]\n\n    # Block ---------------------------------------\n    B_intercept = m.net.block_model(jnp.full((N_id,),0), 1, N_id, sample = True)\n    B_category = m.net.block_model(category, N_grp, N_by_grp, sample = True)\n\n    ## SR shape =  N individuals---------------------------------------\n    sr =  m.net.sender_receiver(\n      focal_individual_predictors,\n      target_individual_predictors, \n      s_mu = 0.4, r_mu = -0.4\n    )\n\n    # Dyadic shape = N dyads--------------------------------------  \n    dr = m.net.dyadic_effect(dyadic_predictors, d_sd=2.5) # Diadic effect intercept only \n    m.dist.bernoulli(logits = B_intercept + B_category + sr + dr, obs=network)\n\nm.fit(model, num_samples = 500, num_warmup = 500, num_chains = 1, thinning = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njax.local_device_count 16\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r  0%|          | 0/1000 [00:00<?, ?it/s]\rwarmup:   0%|          | 1/1000 [00:07<2:04:45,  7.49s/it, 1 steps of size 2.34e+00. acc. prob=0.00]\rwarmup:   4%|â–         | 45/1000 [00:07<01:54,  8.36it/s, 1 steps of size 7.27e-38. acc. prob=0.00] \rwarmup:  10%|â–‰         | 96/1000 [00:07<00:42, 21.41it/s, 1 steps of size 2.19e-61. acc. prob=0.00]\rwarmup:  14%|â–ˆâ–        | 145/1000 [00:07<00:22, 38.20it/s, 1 steps of size 4.92e-100. acc. prob=0.00]\rwarmup:  19%|â–ˆâ–‰        | 194/1000 [00:07<00:13, 60.14it/s, 1 steps of size 2.12e-139. acc. prob=0.00]\rwarmup:  24%|â–ˆâ–ˆâ–       | 238/1000 [00:08<00:09, 83.76it/s, 1 steps of size 2.24e-160. acc. prob=0.00]\rwarmup:  28%|â–ˆâ–ˆâ–Š       | 280/1000 [00:08<00:06, 109.31it/s, 1 steps of size 1.48e-192. acc. prob=0.00]\rwarmup:  32%|â–ˆâ–ˆâ–ˆâ–      | 319/1000 [00:08<00:04, 137.27it/s, 1 steps of size 2.00e-214. acc. prob=0.00]\rwarmup:  36%|â–ˆâ–ˆâ–ˆâ–Œ      | 358/1000 [00:08<00:03, 169.68it/s, 1 steps of size 4.18e-230. acc. prob=0.00]\rwarmup:  40%|â–ˆâ–ˆâ–ˆâ–‰      | 396/1000 [00:08<00:03, 200.04it/s, 1 steps of size 1.36e-242. acc. prob=0.00]\rwarmup:  43%|â–ˆâ–ˆâ–ˆâ–ˆâ–Ž     | 434/1000 [00:08<00:02, 200.49it/s, 1 steps of size 2.07e-253. acc. prob=0.00]\rwarmup:  47%|â–ˆâ–ˆâ–ˆâ–ˆâ–‹     | 466/1000 [00:08<00:02, 214.75it/s, 1 steps of size 1.05e-273. acc. prob=0.00]\rsample:  51%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     | 507/1000 [00:08<00:01, 253.55it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  55%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œ    | 551/1000 [00:08<00:01, 293.77it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  60%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‰    | 597/1000 [00:09<00:01, 332.71it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  65%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–   | 647/1000 [00:09<00:00, 372.84it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  70%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‰   | 695/1000 [00:09<00:00, 399.87it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  74%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–  | 742/1000 [00:09<00:00, 418.58it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  79%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‰  | 789/1000 [00:09<00:00, 430.82it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  84%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Ž | 835/1000 [00:09<00:00, 434.64it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  88%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Š | 883/1000 [00:09<00:00, 445.24it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  93%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Ž| 934/1000 [00:09<00:00, 463.66it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample:  98%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Š| 982/1000 [00:09<00:00, 465.82it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\rsample: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1000/1000 [00:09<00:00, 100.69it/s, 1 steps of size 8.69e-289. acc. prob=0.00]\n```\n:::\n:::\n\n\n`\n\n## Mathematical Details\n\n### *Main Formula*\nThe model's block structure can be represented by the following formula. Note that the sender-receiver and dyadic effects are not represented here, as they are already accounted for in the [Network model](20.&#32;Network&#32;model.qmd) chapter:\n\n$$\nG_{ij} \\sim \\text{Poisson}(Y_{ij})\n$$ \n\n$$\n\\log(Y_{ij}) = B_{k(i), k(j)} \n$$\n\n\nwhere:\n\n- $B$ is a matrix of intercept parameters unique to the interaction of categories. For example, if there are three groups, then $B$ will be a 3x3 matrix where each element give the rate an individual in group $k$ interacting with an individual in group $l$.\n  \n- We use the function $k$, to return the group identity (i.e., the block) of individual *i*.\n\n\n### *Defining formula sub-equations and prior distributions*\nTo account for all link rates between categories, we can define a square matrix $B$ as follows: the off-diagonal elements represent the link rates between categories $i$ and $j$, while the diagonal elements represent the link rates within category $i$.\n\n$$\nB_{i,j} = \n\\begin{bmatrix}\na_{1,1} & a_{1,2} & \\cdots & a_{1,j} \\\\\na_{2,1} & a_{2,2} & \\cdots & a_{2,j} \\\\\n\\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\na_{i,1} & a_{i,2} & \\cdots & a_{i,j} \n\\end{bmatrix}\n$$\n\n\nAs we consider the link probability within categories to be higher than the link probabilities between categories, we define different priors for the diagonal and the off-diagonal. Priors should also depend on sample size, N, so that the resultant network density approximates empirical networks.\nBasic priors could be:\n\n\n$$\na_{k \\rightarrow k} \\sim \\text{Normal}\\left(\\text{Logit}\\left(\\frac{0.1}{\\sqrt{N_k}}\\right), 1.5\\right)\n$$\n\n$$\na_{k \\rightarrow \\tilde{k}} \\sim \\text{Normal}\\left(\\text{Logit}\\left(\\frac{0.01}{0.5 \\sqrt{N_k} + 0.5 \\sqrt{N_{\\tilde{k}}}}\\right), 1.5\\right)\n$$\n\nwhere:\n\n-   $k \\rightarrow k$ indicates a diagonal element.\n-   $k \\rightarrow \\tilde{k}$ indicates an off-diagonal element.\n\n## Note(s)\n::: callout-note\n- By defining this block model within our network model, we are estimating [<span style=\"color:#0D6EFD\">assortativity ðŸ›ˆ</span>]{#assor} and [<span style=\"color:#0D6EFD\">disassortativity ðŸ›ˆ</span>]{#disassor} for categorical variables.\n  \n- Similarly, for continuous variables, we can generate a block model that includes all continuous variables.\n<!--Correct? -->\n:::\n\n## Reference(s)\n::: {#refs}\n:::\n\n",
    "supporting": [
      "23. Network with block model_files/figure-pdf"
    ],
    "filters": []
  }
}